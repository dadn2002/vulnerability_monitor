from pyvis.network import Network
import matplotlib.colors as mcolors
import random
import networkx as nx
import os
import subprocess
import time
import re
import copy

modules_of_processes = []
G_process_grouped = nx.Graph()
nodes_to_keep_global_graph = []
edges_to_keep_global_graph = []
timer_for_update = 60  # in seconds

def generate_random_color():
    """Generate a random hex color."""
    return "#{:06x}".format(random.randint(0, 0xFFFFFF))

def reading_dataset(file_path):
    """Read dataset and populate modules_of_processes list."""
    print("[i] Reading dataset...")
    with open(file_path, "r") as file:
        modules_of_processes.extend(line.strip() for line in file)

def get_handles_directed_edge_list(root_process_name, default_value='default_pid'):
    handles_data_txt = f"..\\handles_data\\handles_to_{root_process_name.lower()}.txt"

    with open(handles_data_txt, 'r') as file:
        text = file.read()

    # Regular expressions for matching patterns
    pattern_edge1 = re.compile(r'pid: (\d+)')
    pattern_edge2 = re.compile(r'\((\d+)\)')

    lines = text.split('\n')

    main_handle_node = default_value  # Start with default value
    list_has_handle_to_node = []
    edges = []

    for line in lines:
        if 'CodeSetup-stable' in line:
            continue

        # Match the first pattern (pid line)
        match1 = pattern_edge1.search(line)
        if match1:
            if main_handle_node != default_value and list_has_handle_to_node:
                # Create edges with the current main_handle_node
                for node in list_has_handle_to_node:
                    edges.append((main_handle_node, node))
            elif main_handle_node != default_value and not list_has_handle_to_node:
                # Add a default edge when there are no nodes to connect
                edges.append((main_handle_node, ''))

            # Update main_handle_node and clear the list
            main_handle_node = match1.group(1)
            list_has_handle_to_node.clear()

        # Match the second pattern (process line with pid)
        match2 = pattern_edge2.search(line)
        if match2:
            # Add the process node to the list
            list_has_handle_to_node.append(match2.group(1))

    # After processing all lines, add remaining edges
    if main_handle_node != default_value:
        if list_has_handle_to_node:
            for node in list_has_handle_to_node:
                edges.append((main_handle_node, node))
        else:
            # Add a default edge when there are no nodes to connect
            edges.append((main_handle_node, ''))

    return edges

def initializing_graph():
    """Initialize the graph from the dataset."""
    print("[i] Initializing nx graph...")
    colors = list(mcolors.CSS4_COLORS.keys())
    random.shuffle(colors)
    color_map = {}

    for node in modules_of_processes:
        if '),' in node:
            try:
                separated_names = node.split('), ')
                process_name = separated_names[0].split(' (')[0]
                PID_number = separated_names[0].split(' (')[1]
                dll_name = separated_names[1].lower().split('.dll')[0]

                if '.exe' in dll_name:
                    continue

                if process_name not in color_map:
                    color_map[process_name] = colors.pop()

                if not G_process_grouped.has_node(process_name):
                    G_process_grouped.add_node(process_name, title=process_name, node_type='root_node', color=color_map[process_name])

                if not G_process_grouped.has_node(dll_name):
                    G_process_grouped.add_node(dll_name, title=dll_name, node_type='dll_node')

                if not G_process_grouped.has_node(PID_number):
                    G_process_grouped.add_node(PID_number, title=PID_number, node_type='process_node', color=color_map[process_name])

                G_process_grouped.add_edge(process_name, PID_number, color=color_map[process_name])
                G_process_grouped.add_edge(PID_number, dll_name, color=color_map[process_name])
            
            except IndexError as e:
                print(f"[#] Error processing line: {node}")
                print(f"[#] Exception: {e}")
                continue  # Skip to the next line

    pos = nx.spring_layout(G_process_grouped)  # Use spring_layout or any other available layout function
    
    # Draw nodes and edges
    for node_type, color in [('root_node', 'color'), ('process_node', 'color'), ('dll_node', 'lightgrey')]:
        nodes = [node for node, data in G_process_grouped.nodes(data=True) if data.get('node_type') == node_type]
        node_colors = [G_process_grouped.nodes[node].get('color', color) for node in nodes]
        sizes = {'root_node': 5000, 'process_node': 2000, 'dll_node': 1250}
        nx.draw_networkx_nodes(G_process_grouped, pos, nodelist=nodes, node_color=node_colors, node_size=sizes[node_type])

    edge_colors = [G_process_grouped[u][v]['color'] for u, v in G_process_grouped.edges]
    nx.draw_networkx_edges(G_process_grouped, pos, edgelist=G_process_grouped.edges, edge_color=edge_colors, width=1.5)
    nx.draw_networkx_labels(G_process_grouped, pos, font_size=8, font_weight='bold', font_color='black')

    print(f"[+] Generated networkx graph")
    print(f"[i] Number of nodes: {len(G_process_grouped.nodes)}")
    print(f"[i] Number of edges: {len(G_process_grouped.edges)}")

def generate_pyvis_html(output_path, filter_by_process_root):
    """Generate Pyvis HTML visualization."""
    print("[i] Generating pyvis HTML...")

    def random_color():
        """Generate a vibrant random color in hex format."""
        return f'#{random.randint(0, 0xFFFFFF):06x}'

    def generate_node_color(root_color):
        """Generate a color for process nodes based on the root color."""
        r, g, b = [int(root_color[i:i+2], 16) for i in (1, 3, 5)]
        r = min(255, max(0, r + random.randint(-50, 50)))
        g = min(255, max(0, g + random.randint(-50, 50)))
        b = min(255, max(0, b + random.randint(-50, 50)))
        return f'#{r:02x}{g:02x}{b:02x}'

    pyvis_net = Network(height='1000px', width='100%', bgcolor='#222222', font_color='white')

    # Get the root node using the provided filter
    root_node = next((node for node in G_process_grouped.nodes if G_process_grouped.nodes[node].get('node_type') == 'root_node' and filter_by_process_root in node), None)

    if not root_node:
        print(f"No root nodes found with filter: {filter_by_process_root}")
        return

    color_map = {root_node: random_color()}

    nodes_to_keep = set()
    edges_to_keep = set()

    # Collect nodes and edges related to the root node
    nodes_to_keep.add(root_node)
    for neighbor in G_process_grouped.neighbors(root_node):
        nodes_to_keep.add(neighbor)
        edges_to_keep.update((root_node, neighbor))
        for dll_neighbor in G_process_grouped.neighbors(neighbor):
            if G_process_grouped.nodes[dll_neighbor].get('node_type') == 'dll_node':
                nodes_to_keep.add(dll_neighbor)
                edges_to_keep.add((neighbor, dll_neighbor))

    subgraph = G_process_grouped.subgraph(nodes_to_keep)
    pyvis_net.from_nx(subgraph)

    pyvis_net.force_atlas_2based()
    pyvis_net.set_options("""
    var options = {
        "nodes": {
            "size": 30,
            "font": {
                "size": 20,
                "align": "center"
            }
        },
        "edges": {
            "color": {
                "inherit": false
            },
            "smooth": {
                "enabled": true
            },
            "width": 2
        },
        "physics": {
            "enabled": true,
            "barnesHut": {
                "gravitationalConstant": -20000,
                "centralGravity": 0.3,
                "springLength": 200,
                "springConstant": 0.04
            }
        }
    }
    """)

    for node in pyvis_net.nodes:
        node_id = node['id']
        node_type = G_process_grouped.nodes[node_id].get('node_type')
        if node_type == 'root_node':
            node['color'] = color_map.get(node_id, random_color())
            node['size'] = 50
        elif node_type == 'process_node':
            root_node_color = color_map.get(root_node, random_color())
            node['color'] = generate_node_color(root_node_color)
            node['size'] = 30
        else:  # dll_node
            node['color'] = '#808080'
            node['size'] = 20
        
        node['label'] = node_id
        node['font'] = {'size': 16, 'color': 'white', 'align': 'center'}

    for edge in pyvis_net.edges:
        u, v = edge['from'], edge['to']
        edge['color'] = G_process_grouped[u][v].get('color', '#FFFFFF')

    pyvis_net.write_html(output_path)
    print(f"[+] Created: {output_path}")

def generate_directed_pyvis_html(output_path, filter_by_process_root=None):
    """I personally hate this function for some reason i dont know"""

    def edge_exists(edges_to_keep, from_node, to_node):
        """Check if an edge exists in the edges_to_keep list."""
        return any(edge['from'] == from_node and edge['to'] == to_node for edge in edges_to_keep)

    def node_exists(nodes_to_keep, node_id):
        """Check if a node exists in the nodes_to_keep list."""
        return any(node['id'] == node_id for node in nodes_to_keep)

    def generate_node_color(base_color):
        """Generate a color for process nodes based on the root color."""
        r, g, b = [int(base_color[i:i+2], 16) for i in (1, 3, 5)]
        r = min(255, max(0, r + random.randint(-50, 50)))
        g = min(255, max(0, g + random.randint(-50, 50)))
        b = min(255, max(0, b + random.randint(-50, 50)))
        return f'#{r:02x}{g:02x}{b:02x}'

    def remove_duplicates(edges_to_keep):
        """Remove duplicate edges from the edges_to_keep list."""
        # i dont think i need that
        # why did i stopped placing function informational text?
        pass
    
    def update_pyvis_node(pyvis_net, old_node, new_properties):
        """Pyvis does not have a direct way to update nodes so"""
        pass

    pyvis_net = Network(
        height='800px',  # Reduced height for smaller canvas
        width='100%',     # Reduced width for smaller canvas
        bgcolor='#222222', 
        font_color='white', 
        directed=True
    )

    # Adjust physics settings for a more compact layout
    pyvis_net.force_atlas_2based(
        central_gravity=0.5,       # Increased central gravity to pull nodes closer
        spring_length=50,          # Set spring length for closer node spacing
        spring_strength=0.1,       # Adjust spring strength for tighter connections
        damping=0.9                # Adjust damping for smoother movement
    )

    # Customize network options with additional settings
    pyvis_net.set_options("""
        var options = {
            "nodes": {
                "size": 20,
                "font": {
                    "size": 14,
                    "align": "center"
                }
            },
            "edges": {
                "color": {
                    "inherit": false 
                },
                "smooth": {
                    "enabled": true 
                },
                "width": 1 
            },
            "physics": {
                "enabled": true,
                "barnesHut": {
                    "gravitationalConstant": -20000,
                    "centralGravity": 0.3,
                    "springLength": 80,
                    "springConstant": 0.04
                }
            }
        }
    """)

    list_of_directed_handles_edges = get_handles_directed_edge_list(filter_by_process_root)
    
    base_root_node = next(
        (node for node in G_process_grouped.nodes 
         if G_process_grouped.nodes[node].get('node_type') == 'root_node' 
         and filter_by_process_root in node), 
        None
    )
    
    if not base_root_node:
        return

    nodes_to_keep = []
    edges_to_keep = []

    base_root_color = generate_random_color()
    nodes_to_keep.append({
        'id'    : base_root_node,
        'label' : base_root_node,
        'color' : base_root_color,
        'size'  : 60
    })
    if not node_exists(nodes_to_keep_global_graph, base_root_node):
        nodes_to_keep_global_graph.append({
            'type'  : 'root_node',
            'id'    : base_root_node,
            'label' : base_root_node
        })

    #print(base_root_node)

    #for edge in list_of_directed_handles_edges:
    #    print(edge)
    
    # Populate pyvis_net with the nodes and their edges (organized this time)
    for main_process, handle_process in list_of_directed_handles_edges:
        #print(main_process, handle_process)
        # If the edge is malformed for some reason (example: code-setup)
        if 'setup' in handle_process:
            continue

        # Add the nodes connected to the base_root_node
        if not node_exists(nodes_to_keep, main_process):
            #print('main_process', main_process)   
            existing_node_color = next(
                (node['color'] for node in nodes_to_keep if edge_exists(edges_to_keep, node['id'], main_process)), 
                base_root_color  # Default to base root color if no connected node color found
            )
            node_color = generate_node_color(existing_node_color)
            nodes_to_keep.append({
                'id'    : main_process,
                'label' : main_process,
                'color' : node_color,
                'size'  : 20
            })

            # There must be only one edge from root to main_process (Redundancy??? I say it's not)
            #print(base_root_node, main_process)
            if not edge_exists(edges_to_keep, base_root_node, main_process):
                #print('new edge rootroot mainprocess')
                edges_to_keep.append({
                    'from'  : base_root_node,
                    'to'    : main_process,
                    'color' : '#FF8888'
                })

        if not node_exists(nodes_to_keep_global_graph, main_process):
            nodes_to_keep_global_graph.append({
                'type'  : 'process_node',
                'id'    : main_process,
                'label' : main_process
            })

            if not edge_exists(edges_to_keep_global_graph, base_root_node, main_process):
                #print('new edge rootroot mainprocess')
                edges_to_keep_global_graph.append({
                    'from'  : base_root_node,
                    'to'    : main_process
                })
    
    # Add the handle_process nodes that main_process is connected to
    for main_process, handle_process in list_of_directed_handles_edges:
        #if base_root_node == 'msedge.exe':
        #    print(main_process, handle_process)
        if not handle_process:
            continue
        if not node_exists(nodes_to_keep, handle_process):
            #print(handle_process)
            nodes_to_keep.append({
                'id'    : handle_process,
                'label' : handle_process,
                'color' : '#000000', # #000000 is the default value for handle_nodes (replaced it connected to root_node)
                'size'  : 20
            })
            nodes_to_keep_global_graph.append({
                'type'  : 'process_node',
                'id'    : handle_process,
                'label' : handle_process
            })

        # always add them
        edges_to_keep.append({
            'from'  : main_process,
            'to'    : handle_process,
            'color' : '#FF0000'
        })

        if not edge_exists(edges_to_keep_global_graph, main_process, handle_process):
            edges_to_keep_global_graph.append({
                'from'  : main_process,
                'to'    : handle_process
            })

    # Add the root_nodes of the handle_process
    for _, handle_process in list_of_directed_handles_edges:
        for root_node_of_handle_process in G_process_grouped.nodes:
            if root_node_of_handle_process == base_root_node:
                # my sanity
                continue
            if (G_process_grouped.nodes[root_node_of_handle_process].get('node_type') == 'root_node' 
                and G_process_grouped.has_edge(root_node_of_handle_process, handle_process)):
                # IS DIRECTED OMG
                if not edge_exists(edges_to_keep, root_node_of_handle_process, handle_process):
                    #print(root_node_of_handle_process, handle_process)
                    if not node_exists(nodes_to_keep, root_node_of_handle_process):
                        nodes_to_keep.append({
                            'id'    : root_node_of_handle_process,
                            'label' : root_node_of_handle_process,
                            'color' : generate_random_color(),
                            'size'  : 40
                        })
                    # PYTHON NEED IDENTATION TO WORK OBVIOUSLY
                    edges_to_keep.append({
                        'from'  : root_node_of_handle_process,
                        'to'    : handle_process,
                        'color' : '#BBBBBB'
                    })
                    # Update the color of the handle_process node if it exists in nodes_to_keep
                    color_root_node_of_handle_process = next(
                        (n['color'] for n in nodes_to_keep if n['id'] == root_node_of_handle_process), 
                        None  # Default color if not found
                    )
                    node_of_handle_process = next(
                        (node for node in nodes_to_keep if node['id'] == handle_process), 
                        None
                    )

                    if node_of_handle_process:
                        node_of_handle_process['color'] = generate_node_color(color_root_node_of_handle_process)
                        break
                    else:
                        # Handle the case where the node is not found, if necessary
                        pass

                if not edge_exists(edges_to_keep_global_graph, root_node_of_handle_process, handle_process):
                    if not node_exists(nodes_to_keep_global_graph, root_node_of_handle_process):
                        nodes_to_keep_global_graph.append({
                            'type'  : 'root_node',
                            'id'    : root_node_of_handle_process,
                            'label' : root_node_of_handle_process
                        })
                    edges_to_keep_global_graph.append({
                        'from'  : root_node_of_handle_process,
                        'to'    : handle_process
                    })
    
    #if base_root_node == 'powershell.exe':
    #    for edge in list_of_directed_handles_edges:
    #        print(edge)
    #        for edge in edges_to_keep:
    #            print(edge)
    #wait = input("STOP THERE")

    # Add nodes and edges to the network
    for node in nodes_to_keep:
        pyvis_net.add_node(node['id'], **{k: v for k, v in node.items()})
    
    for edge in edges_to_keep:
        pyvis_net.add_edge(edge['from'], edge['to'], **{k: v for k, v in edge.items() if k not in ['from', 'to']})

    pyvis_net.write_html(output_path)
    print(f"[+] Created: {output_path}")


    generate_data_start_time = time.time()

    ### 1. Create a MultiDiGraph ###
    nx_multi_graph = nx.MultiDiGraph()

    # Add nodes
    for node in nodes_to_keep:
        nx_multi_graph.add_node(node['id'], **node)

    # Add edges
    for edge in edges_to_keep:
        from_node = edge['from']
        to_node = edge['to']
        weight = edge.get('weight', 1)  # Default weight to 1 if not specified
        nx_multi_graph.add_edge(from_node, to_node, weight=weight)

    print(f"Root Name: {root_name}")
    print(f"Number of nodes in Graph                : {nx_multi_graph.number_of_nodes()}")
    print(f"Number of edges in MultiDiGraph         : {nx_multi_graph.number_of_edges()}")

    ### 2. Convert to a Weighted DiGraph ###
    nx_weighted_graph = nx.DiGraph()

    # Add nodes to weighted graph
    nx_weighted_graph.add_nodes_from(nx_multi_graph.nodes(data=True))

    # Aggregate edges and sum weights
    for u, v, data in nx_multi_graph.edges(data=True):
        w = data.get('weight', 1)
        if nx_weighted_graph.has_edge(u, v):
            nx_weighted_graph[u][v]['weight'] += w
        else:
            nx_weighted_graph.add_edge(u, v, weight=w)

    print(f"Number of edges in Weighted DiGraph     : {nx_weighted_graph.number_of_edges()}")

    ### 3. Compute Centrality Measures ###
    # Weighted degrees
    degree_dict = dict(nx_weighted_graph.degree(weight='weight'))
    in_degree_dict = dict(nx_weighted_graph.in_degree(weight='weight'))
    out_degree_dict = dict(nx_weighted_graph.out_degree(weight='weight'))

    # Weighted degree centrality (manual computation)
    total_weight = sum(degree_dict.values())
    if total_weight == 0:
        print("[-] Total weight is zero. Cannot calculate degree centrality.")
        degree_centrality = {}  # Or set a default value
    else:
        degree_centrality = {node: deg / total_weight for node, deg in degree_dict.items()}

    # Betweenness centrality
    betweenness_centrality = nx.betweenness_centrality(nx_weighted_graph, weight='weight', normalized=True)

    # Closeness centrality
    closeness_centrality = nx.closeness_centrality(nx_weighted_graph, distance='weight')

    # Eigenvector centrality
    try:
        eigenvector_centrality = nx.eigenvector_centrality(nx_weighted_graph, max_iter=1000, weight='weight')
    except nx.PowerIterationFailedConvergence:
        print("Eigenvector centrality did not converge within the iteration limit.")
        eigenvector_centrality = {node: 0 for node in nx_weighted_graph.nodes()}

    # Modularity Class using Greedy Modularity Communities
    undirected_graph = nx_weighted_graph.to_undirected()
    communities_generator = nx.algorithms.community.greedy_modularity_communities(undirected_graph, weight='weight')
    modularity_class = {}
    for idx, community in enumerate(communities_generator):
        for node in community:
            modularity_class[node] = idx

    # Local clustering coefficient
    local_clustering = nx.clustering(nx_weighted_graph, weight='weight')

    ### 4. Prepare Data for Output ###
    data_of_nodes = []
    root_node_names = {node for node in nx_weighted_graph.nodes if not str(node).isdigit()}

    # Check if graph is connected
    if not nx.is_weakly_connected(nx_weighted_graph):
        print("Warning: The graph is not weakly connected. Some metrics may not be meaningful.")

    for node in nx_weighted_graph.nodes():
        node_data = nx_weighted_graph.nodes[node]
        label = str(node_data.get('label', node))
        
        data_entry = (
            label,
            degree_dict.get(node, 0),
            in_degree_dict.get(node, 0),
            out_degree_dict.get(node, 0),
            degree_centrality.get(node, 0),
            betweenness_centrality.get(node, 0),
            closeness_centrality.get(node, 0),
            eigenvector_centrality.get(node, 0),
            modularity_class.get(node, 'Unknown'),
            local_clustering.get(node, 0)
        )
        
        data_of_nodes.append(data_entry)

    generate_data_end_time = time.time()
    elapsed_time = generate_data_end_time - generate_data_start_time
    print(f"[+] Generated data in {elapsed_time:.4f} seconds")

    ### 5. Write Data to File ###
    output_filename = f"data_of_{os.path.basename(output_path).replace('.html', '')}.txt"
    output_dir = os.path.join("data_of_graphs")
    os.makedirs(output_dir, exist_ok=True)
    output_filepath = os.path.join(output_dir, output_filename)

    with open(output_filepath, 'w') as file:
        header = "Label, Degree, InDegree, OutDegree, Degree Centrality, Betweenness Centrality, Closeness Centrality, Eigenvector Centrality, Modularity Class, Local Clustering Coefficient"
        file.write(f"{header}\n")
        for line in data_of_nodes:
            line_str = ', '.join(map(str, line))
            file.write(f"{line_str}\n")

    print(f"[+] Data written to {output_filepath}")

def generate_global_redacted_pyvis_html(output_path):
    def generate_color_close_to(color, variance):
        rgb = mcolors.hex2color(color)
        variance_rgb = [min(max(c + random.uniform(-variance, variance), 0), 1) for c in rgb]
        return mcolors.to_hex(variance_rgb)

    pyvis_net = Network(
        height='800px',
        width='100%',
        bgcolor='#222222',
        font_color='white',
        directed=True
    )

    pyvis_net.force_atlas_2based(
        central_gravity=0.5,
        spring_length=50,
        spring_strength=0.1,
        damping=0.9
    )

    pyvis_net.set_options("""
        var options = {
            "nodes": {
                "size": 20,
                "font": {
                    "size": 14,
                    "align": "center"
                }
            },
            "edges": {
                "color": {
                    "inherit": false
                },
                "smooth": {
                    "enabled": true
                },
                "width": 1
            },
            "physics": {
                "enabled": true,
                "barnesHut": {
                    "gravitationalConstant": -20000,
                    "centralGravity": 0.3,
                    "springLength": 80,
                    "springConstant": 0.04
                }
            }
        }
    """)

    # Plot all nodes and assign random colors to root nodes
    root_node_colors = {}
    for node in nodes_to_keep_global_graph:
        node_id = node['id']
        node_type = node.get('type')
        pyvis_net.add_node(node_id, **{k: v for k, v in node.items()})

        if node_type == 'root_node':
            root_color                              = generate_random_color()
            root_node_colors[node_id]               = root_color
            pyvis_net.get_node(node_id)['color']    = root_color
            pyvis_net.get_node(node_id)['size']     = 40

    # Assign colors to nodes connected to root nodes
    for node in nodes_to_keep_global_graph:
        node_id = node['id']
        node_type = node.get('type')
        if node_type != 'root_node':
            connected_edges = [edge for edge in edges_to_keep_global_graph if edge['from'] == node_id or edge['to'] == node_id]
            connected_root_nodes = [edge['from'] if edge['to'] == node_id else edge['to'] for edge in connected_edges if (edge['from'] in root_node_colors or edge['to'] in root_node_colors)]
            if connected_root_nodes:
                root_colors = [root_node_colors[edge] for edge in connected_root_nodes if edge in root_node_colors]
                if root_colors:
                    avg_color = mcolors.to_hex([sum(mcolors.hex2color(color)[i] for color in root_colors) / len(root_colors) for i in range(3)])
                    close_color = generate_color_close_to(avg_color, 0.2)
                    pyvis_net.get_node(node_id)['color'] = close_color

    # Plot all edges with color mapping
    for edge in edges_to_keep_global_graph:
        source = edge['from']
        target = edge['to']
        source_node = pyvis_net.get_node(source)
        target_node = pyvis_net.get_node(target)
        
        if source_node and target_node:
            source_type = source_node.get('type')
            target_type = target_node.get('type')

            if source_type == 'root_node' and target_type == 'process_node':
                edge_color = '#FFB6C1'  # Light pink for edges from root_node to process_node
            elif source_type == 'process_node' and target_type == 'process_node':
                edge_color = '#FF0000'  # Red for edges between process_nodes
            else:
                edge_color = '#FFFFFF'  # Default color for other cases
            
            pyvis_net.add_edge(source, target, color=edge_color, **{k: v for k, v in edge.items() if k not in ['from', 'to']})

    # Save the HTML visualization
    pyvis_net.write_html(output_path)
    print(f"[+] Created: {output_path}")

    # Step 2: Calculate metrics
    generate_data_start_time = time.time()
    nx_graph = nx.DiGraph()
    for node in nodes_to_keep_global_graph:
        node_id = node['id']
        nx_graph.add_node(node_id, **node)

    for edge in edges_to_keep_global_graph:
        nx_graph.add_edge(edge['from'], edge['to'], **{k: v for k, v in edge.items() if k not in ['from', 'to']})

    degree_centrality = nx.degree_centrality(nx_graph)
    betweenness_centrality = nx.betweenness_centrality(nx_graph)
    closeness_centrality = nx.closeness_centrality(nx_graph)

    try:
        eigenvector_centrality = nx.eigenvector_centrality(nx_graph, max_iter=500)
    except nx.PowerIterationFailedConvergence:
        print("Eigenvector centrality calculation failed to converge.")
        eigenvector_centrality = {}

    modularity_class = {node: i for i, community in enumerate(nx.algorithms.community.greedy_modularity_communities(nx_graph)) for node in community}
    local_clustering_coefficient = nx.clustering(nx_graph)

    # Find root nodes (non-numeric names) and create a mapping for concatenation
    root_node_names = {node for node in nx_graph.nodes if not node.isdigit()}

    data_of_nodes = []
    for node, data in nx_graph.nodes(data=True):
        if node.isdigit():
            root_node = next(
                (root_node for root_node in root_node_names
                 if nx_graph.has_edge(root_node, node)),
                None
            )
            if root_node:
                label = f"{root_node} ({node})"
            else:
                label = f"Unknown ({node})"

            if not nx.is_connected(nx_graph.to_undirected()):
                print("The graph is not connected. Eigenvector centrality may not be calculated correctly.")

            data_of_nodes.append((
                label,
                nx_graph.degree[node],
                nx_graph.in_degree(node),
                nx_graph.out_degree(node),
                degree_centrality.get(node, 0),
                betweenness_centrality.get(node, 0),
                closeness_centrality.get(node, 0),
                eigenvector_centrality.get(node, 0),
                modularity_class.get(node, 'Unknown'),
                local_clustering_coefficient.get(node, 0)
            ))

    # Save the data in the 'data_of_graphs' folder
    folder_path = os.path.join(os.path.dirname(__file__), 'data_of_graphs')
    os.makedirs(folder_path, exist_ok=True)
    
    # Only keep the filename, not the entire path
    filename = os.path.basename(output_path).replace('html', 'txt')
    output_path3 = os.path.join(folder_path, f"data_of_{filename}")
    #print("\n\n" + output_path3)

    with open(output_path3, 'w') as file:
        header = "Label, Degree, InDegree, OutDegree, Degree Centrality, Betweenness, Closeness, Eigenvector, Modularity, Local Clustering"
        file.write(f"{header}\n")
        for line in data_of_nodes:
            line_str = ', '.join(map(str, line))          
            file.write(f"{line_str}\n")

    generate_data_end_time = time.time()

    print(f"[+] Generated data in {generate_data_end_time - generate_data_start_time:.4f} seconds")

def extract_root_nodes_with_multiple_process_nodes(min_count=2):
    """Extract root nodes connected to more than min_count process nodes."""
    print(f"[i] Extracting root nodes with more than {min_count} process nodes...")
    result = []
    
    for root_node in G_process_grouped.nodes:
        if G_process_grouped.nodes[root_node].get('node_type') == 'root_node':
            connected_process_nodes = [n for n in G_process_grouped.neighbors(root_node)
                                       if G_process_grouped.nodes[n].get('node_type') == 'process_node']
            if len(connected_process_nodes) > min_count or 'processhacker' in root_node.lower():
                result.append(root_node)
    
    #print(f"Root nodes with more than {min_count} process nodes: {result}")
    return result

def run_git_commands():
    """Run git add, git commit, and git push commands in sequence."""
    try:
        # Run git add .
        print("[i] Running 'git add .\\graphs\\'...")
        subprocess.run(["git", "add", ".\\graphs\\"], check=True)

        print("[i] Running 'git add .\\data_of_graphs\\'...")
        subprocess.run(["git", "add", ".\\data_of_graphs\\"], check=True)

        print("[i] Running 'git add .\\the_big_one\\global_redacted_pyvis_process_network_graph.html'")
        subprocess.run(["git", "add", ".\\the_big_one\\global_redacted_pyvis_process_network_graph.html"], check=True)
        
        # Run git commit -m "default"
        print("[i] Running 'git commit -m \"System Scan Commit\"'...")
        subprocess.run(["git", "commit", "-m", "default"], check=True)
        
        # Run git push
        print("[i] Running 'git push'...")
        subprocess.run(["git", "push"], check=True)
        
        print("[i] Git commands executed successfully.")
    
    except subprocess.CalledProcessError as e:
        print(f"[#] An error occurred: {e}")

def run_python_script(script_path):
    """Run the specified Python script."""
    try:
        # Ensure the script path is absolute
        script_path = os.path.abspath(script_path)
        print(f"[i] Running {update_data_script_path}...")
        
        # Run the Python script
        result = subprocess.run(["python", script_path], capture_output=True, text=True, check=True)
        
        # Print output and errors (if any)
        #print("Output:\n", result.stdout)
        
        print(f"[+] Successfully executed {update_data_script_path}")
    
    except subprocess.CalledProcessError as e:
        print(f"[#] An error occurred while running {script_path}: {e}")

if __name__ == "__main__":
    dataset_path = os.path.join("..", "list_MODULES_imports.txt")
    update_data_script_path = "updating_dataset.py"  # Replace with the path to your target script

    while True:
        os.system("cls")

        run_python_script(update_data_script_path)

        print(f'[+] begin html generation')
        filter_by_process_root = ''
        reading_dataset(dataset_path)
        initializing_graph()
        generated_for_this_root_nodes = extract_root_nodes_with_multiple_process_nodes(min_count=2)

        for root_name in generated_for_this_root_nodes:
            output_path1 = os.path.join("graphs", f"undirected_{root_name.replace('.exe', '').lower()}_process_network_graph.html")
            generate_pyvis_html(output_path1, root_name.replace('.exe', ''))
            #wait = input('STOP THERE')
            output_path2 = os.path.join("graphs", f"directed_{root_name.replace('.exe', '').lower()}_process_network_graph.html")
            generate_directed_pyvis_html(output_path2, root_name.replace('.exe', ''))
        output_path3 = os.path.join("the_big_one", "global_redacted_pyvis_process_network_graph.html")
        generate_global_redacted_pyvis_html(output_path3)
        #wait = input('STOP THERE')
        run_git_commands()

        print(f'[i] {timer_for_update} seconds timer begin')
        time.sleep(timer_for_update) #Seconds
        