from pyvis.network import Network
import matplotlib.colors as mcolors
import random
import networkx as nx
import os
import subprocess
import time
import re
import copy

modules_of_processes = []
G_process_grouped = nx.Graph()
timer_for_update = 60  # in seconds

def reading_dataset(file_path):
    """Read dataset and populate modules_of_processes list."""
    print("[i] Reading dataset...")
    with open(file_path, "r") as file:
        modules_of_processes.extend(line.strip() for line in file)

def get_handles_directed_edge_list(root_process_name, default_value='default_pid'):
    handles_data_txt = f"..\\handles_data\\handles_to_{root_process_name.lower()}.txt"

    with open(handles_data_txt, 'r') as file:
        text = file.read()

    # Regular expressions for matching patterns
    pattern_edge1 = re.compile(r'pid: (\d+)')
    pattern_edge2 = re.compile(r'\((\d+)\)')

    lines = text.split('\n')

    main_handle_node = default_value  # Start with default value
    list_has_handle_to_node = []
    edges = []

    for line in lines:
        if 'CodeSetup-stable' in line:
            continue

        # Match the first pattern (pid line)
        match1 = pattern_edge1.search(line)
        if match1:
            if main_handle_node != default_value and list_has_handle_to_node:
                # Create edges with the current main_handle_node
                for node in list_has_handle_to_node:
                    edges.append((main_handle_node, node))
            elif main_handle_node != default_value and not list_has_handle_to_node:
                # Add a default edge when there are no nodes to connect
                edges.append((main_handle_node, ''))

            # Update main_handle_node and clear the list
            main_handle_node = match1.group(1)
            list_has_handle_to_node.clear()

        # Match the second pattern (process line with pid)
        match2 = pattern_edge2.search(line)
        if match2:
            # Add the process node to the list
            list_has_handle_to_node.append(match2.group(1))

    # After processing all lines, add remaining edges
    if main_handle_node != default_value:
        if list_has_handle_to_node:
            for node in list_has_handle_to_node:
                edges.append((main_handle_node, node))
        else:
            # Add a default edge when there are no nodes to connect
            edges.append((main_handle_node, ''))

    return edges

def initializing_graph():
    """Initialize the graph from the dataset."""
    print("[i] Initializing nx graph...")
    colors = list(mcolors.CSS4_COLORS.keys())
    random.shuffle(colors)
    color_map = {}

    for node in modules_of_processes:
        if '),' in node:
            try:
                separated_names = node.split('), ')
                process_name = separated_names[0].split(' (')[0]
                PID_number = separated_names[0].split(' (')[1]
                dll_name = separated_names[1].lower().split('.dll')[0]

                if '.exe' in dll_name:
                    continue

                if process_name not in color_map:
                    color_map[process_name] = colors.pop()

                if not G_process_grouped.has_node(process_name):
                    G_process_grouped.add_node(process_name, title=process_name, node_type='root_node', color=color_map[process_name])

                if not G_process_grouped.has_node(dll_name):
                    G_process_grouped.add_node(dll_name, title=dll_name, node_type='dll_node')

                if not G_process_grouped.has_node(PID_number):
                    G_process_grouped.add_node(PID_number, title=PID_number, node_type='process_node', color=color_map[process_name])

                G_process_grouped.add_edge(process_name, PID_number, color=color_map[process_name])
                G_process_grouped.add_edge(PID_number, dll_name, color=color_map[process_name])
            
            except IndexError as e:
                print(f"[#] Error processing line: {node}")
                print(f"[#] Exception: {e}")
                continue  # Skip to the next line

    pos = nx.spring_layout(G_process_grouped)  # Use spring_layout or any other available layout function
    
    # Draw nodes and edges
    for node_type, color in [('root_node', 'color'), ('process_node', 'color'), ('dll_node', 'lightgrey')]:
        nodes = [node for node, data in G_process_grouped.nodes(data=True) if data.get('node_type') == node_type]
        node_colors = [G_process_grouped.nodes[node].get('color', color) for node in nodes]
        sizes = {'root_node': 5000, 'process_node': 2000, 'dll_node': 1250}
        nx.draw_networkx_nodes(G_process_grouped, pos, nodelist=nodes, node_color=node_colors, node_size=sizes[node_type])

    edge_colors = [G_process_grouped[u][v]['color'] for u, v in G_process_grouped.edges]
    nx.draw_networkx_edges(G_process_grouped, pos, edgelist=G_process_grouped.edges, edge_color=edge_colors, width=1.5)
    nx.draw_networkx_labels(G_process_grouped, pos, font_size=8, font_weight='bold', font_color='black')

    print(f"[+] Generated networkx graph")
    print(f"[i] Number of nodes: {len(G_process_grouped.nodes)}")
    print(f"[i] Number of edges: {len(G_process_grouped.edges)}")

def generate_pyvis_html(output_path, filter_by_process_root):
    """Generate Pyvis HTML visualization."""
    print("[i] Generating pyvis HTML...")

    def random_color():
        """Generate a vibrant random color in hex format."""
        return f'#{random.randint(0, 0xFFFFFF):06x}'

    def generate_node_color(root_color):
        """Generate a color for process nodes based on the root color."""
        r, g, b = [int(root_color[i:i+2], 16) for i in (1, 3, 5)]
        r = min(255, max(0, r + random.randint(-50, 50)))
        g = min(255, max(0, g + random.randint(-50, 50)))
        b = min(255, max(0, b + random.randint(-50, 50)))
        return f'#{r:02x}{g:02x}{b:02x}'

    pyvis_net = Network(height='1000px', width='100%', bgcolor='#222222', font_color='white')

    # Get the root node using the provided filter
    root_node = next((node for node in G_process_grouped.nodes if G_process_grouped.nodes[node].get('node_type') == 'root_node' and filter_by_process_root in node), None)

    if not root_node:
        print(f"No root nodes found with filter: {filter_by_process_root}")
        return

    color_map = {root_node: random_color()}

    nodes_to_keep = set()
    edges_to_keep = set()

    # Collect nodes and edges related to the root node
    nodes_to_keep.add(root_node)
    for neighbor in G_process_grouped.neighbors(root_node):
        nodes_to_keep.add(neighbor)
        edges_to_keep.update((root_node, neighbor))
        for dll_neighbor in G_process_grouped.neighbors(neighbor):
            if G_process_grouped.nodes[dll_neighbor].get('node_type') == 'dll_node':
                nodes_to_keep.add(dll_neighbor)
                edges_to_keep.add((neighbor, dll_neighbor))

    subgraph = G_process_grouped.subgraph(nodes_to_keep)
    pyvis_net.from_nx(subgraph)

    pyvis_net.force_atlas_2based()
    pyvis_net.set_options("""
    var options = {
        "nodes": {
            "size": 30,
            "font": {
                "size": 20,
                "align": "center"
            }
        },
        "edges": {
            "color": {
                "inherit": false
            },
            "smooth": {
                "enabled": true
            },
            "width": 2
        },
        "physics": {
            "enabled": true,
            "barnesHut": {
                "gravitationalConstant": -20000,
                "centralGravity": 0.3,
                "springLength": 200,
                "springConstant": 0.04
            }
        }
    }
    """)

    for node in pyvis_net.nodes:
        node_id = node['id']
        node_type = G_process_grouped.nodes[node_id].get('node_type')
        if node_type == 'root_node':
            node['color'] = color_map.get(node_id, random_color())
            node['size'] = 50
        elif node_type == 'process_node':
            root_node_color = color_map.get(root_node, random_color())
            node['color'] = generate_node_color(root_node_color)
            node['size'] = 30
        else:  # dll_node
            node['color'] = '#808080'
            node['size'] = 20
        
        node['label'] = node_id
        node['font'] = {'size': 16, 'color': 'white', 'align': 'center'}

    for edge in pyvis_net.edges:
        u, v = edge['from'], edge['to']
        edge['color'] = G_process_grouped[u][v].get('color', '#FFFFFF')

    pyvis_net.write_html(output_path)
    print(f"[+] Created: {output_path}")

def generate_directed_pyvis_html(output_path, filter_by_process_root=None):
    """I personally hate this function for some reason i dont know"""

    def edge_exists(edges_to_keep, from_node, to_node):
        """Check if an edge exists in the edges_to_keep list."""
        return any(edge['from'] == from_node and edge['to'] == to_node for edge in edges_to_keep)

    def node_exists(nodes_to_keep, node_id):
        """Check if a node exists in the nodes_to_keep list."""
        return any(node['id'] == node_id for node in nodes_to_keep)

    def generate_random_color():
        """Generate a random HEX color."""
        return f'#{random.randint(0, 0xFFFFFF):06x}'

    def generate_node_color(base_color):
        """Generate a color for process nodes based on the root color."""
        r, g, b = [int(base_color[i:i+2], 16) for i in (1, 3, 5)]
        r = min(255, max(0, r + random.randint(-50, 50)))
        g = min(255, max(0, g + random.randint(-50, 50)))
        b = min(255, max(0, b + random.randint(-50, 50)))
        return f'#{r:02x}{g:02x}{b:02x}'

    def remove_duplicates(edges_to_keep):
        """Remove duplicate edges from the edges_to_keep list."""
        pass
    
    def update_pyvis_node(pyvis_net, old_node, new_properties):
        """Pyvis does not have a direct way to update nodes so"""
        pass

    pyvis_net = Network(
        height='800px',  # Reduced height for smaller canvas
        width='100%',     # Reduced width for smaller canvas
        bgcolor='#222222', 
        font_color='white', 
        directed=True
    )

    # Adjust physics settings for a more compact layout
    pyvis_net.force_atlas_2based(
        central_gravity=0.5,       # Increased central gravity to pull nodes closer
        spring_length=50,          # Set spring length for closer node spacing
        spring_strength=0.1,       # Adjust spring strength for tighter connections
        damping=0.9                # Adjust damping for smoother movement
    )

    # Customize network options with additional settings
    pyvis_net.set_options("""
        var options = {
            "nodes": {
                "size": 20,
                "font": {
                    "size": 14,
                    "align": "center"
                }
            },
            "edges": {
                "color": {
                    "inherit": false 
                },
                "smooth": {
                    "enabled": true 
                },
                "width": 1 
            },
            "physics": {
                "enabled": true,
                "barnesHut": {
                    "gravitationalConstant": -20000,
                    "centralGravity": 0.3,
                    "springLength": 80,
                    "springConstant": 0.04
                }
            }
        }
    """)

    list_of_directed_handles_edges = get_handles_directed_edge_list(filter_by_process_root)
    
    base_root_node = next(
        (node for node in G_process_grouped.nodes 
         if G_process_grouped.nodes[node].get('node_type') == 'root_node' 
         and filter_by_process_root in node), 
        None
    )
    
    if not base_root_node:
        return

    nodes_to_keep = []
    edges_to_keep = []

    base_root_color = generate_random_color()
    nodes_to_keep.append({
        'id': base_root_node,
        'label': base_root_node,
        'color': base_root_color,
        'size': 60
    })

    #print(base_root_node)

    #for edge in list_of_directed_handles_edges:
    #    print(edge)
    
    # Populate pyvis_net with the nodes and their edges (organized this time)
    for main_process, handle_process in list_of_directed_handles_edges:
        #print(main_process, handle_process)
        # If the edge is malformed for some reason (example: code-setup)
        if 'setup' in handle_process:
            continue

        # Add the nodes connected to the base_root_node
        if not node_exists(nodes_to_keep, main_process):
            #print('main_process', main_process)   
            existing_node_color = next(
                (node['color'] for node in nodes_to_keep if edge_exists(edges_to_keep, node['id'], main_process)), 
                base_root_color  # Default to base root color if no connected node color found
            )
            node_color = generate_node_color(existing_node_color)
            nodes_to_keep.append({
                'id'    : main_process,
                'label' : main_process,
                'color' : node_color,
                'size'  : 20
            })

            # There must be only one edge from root to main_process (Redundancy??? I say it's not)
            #print(base_root_node, main_process)
            if not edge_exists(edges_to_keep, base_root_node, main_process):
                #print('new edge rootroot mainprocess')
                edges_to_keep.append({
                    'from'  : base_root_node,
                    'to'    : main_process,
                    'color' : '#FF8888'
                })
    
    # Add the handle_process nodes that main_process is connected to
    for main_process, handle_process in list_of_directed_handles_edges:
        #if base_root_node == 'msedge.exe':
        #    print(main_process, handle_process)
        if not handle_process:
            continue
        if not node_exists(nodes_to_keep, handle_process):
            #print(handle_process)
            nodes_to_keep.append({
                'id'    : handle_process,
                'label' : handle_process,
                'color' : '#000000', # #000000 is the default value for handle_nodes (replaced it connected to root_node)
                'size'  : 20
            })
        edges_to_keep.append({
            'from'  : main_process,
            'to'    : handle_process,
            'color' : '#FF0000'
        })

    # Add the root_nodes of the handle_process
    for _, handle_process in list_of_directed_handles_edges:
        for root_node_of_handle_process in G_process_grouped.nodes:
            if root_node_of_handle_process == base_root_node:
                # my sanity
                continue
            if (G_process_grouped.nodes[root_node_of_handle_process].get('node_type') == 'root_node' 
                and G_process_grouped.has_edge(root_node_of_handle_process, handle_process)):
                # IS DIRECTED OMG
                if not edge_exists(edges_to_keep, root_node_of_handle_process, handle_process):
                    #print(root_node_of_handle_process, handle_process)
                    if not node_exists(nodes_to_keep, root_node_of_handle_process):
                        nodes_to_keep.append({
                            'id'    : root_node_of_handle_process,
                            'label' : root_node_of_handle_process,
                            'color' : generate_random_color(),
                            'size'  : 40
                        })
                    edges_to_keep.append({
                        'from'  : root_node_of_handle_process,
                        'to'    : handle_process,
                        'color' : '#BBBBBB'
                    })

                    # Update the color of the handle_process node if it exists in nodes_to_keep
                    for node in nodes_to_keep:
                        if node['id'] == handle_process:
                            color_root_node_of_handle_process = next(
                                (n['color'] for n in nodes_to_keep if n['id'] == root_node_of_handle_process), 
                                None  # Default color if not found
                            )
                            node['color'] = generate_node_color(color_root_node_of_handle_process)
                            break
    
    #if base_root_node == 'msedge.exe':
    #for edge in list_of_directed_handles_edges:
    #    print(edge)
    #    for edge in edges_to_keep:
    #        print(edge)

    # Add nodes and edges to the network
    for node in nodes_to_keep:
        pyvis_net.add_node(node['id'], **{k: v for k, v in node.items()})
    
    for edge in edges_to_keep:
        pyvis_net.add_edge(edge['from'], edge['to'], **{k: v for k, v in edge.items() if k not in ['from', 'to']})

    pyvis_net.write_html(output_path)
    print(f"[+] Created: {output_path}")

    generate_data_start_time = time.time()
    # Convert pyvis_net to NetworkX graph
    nx_graph = nx.DiGraph()
    for node in nodes_to_keep:
        # Add nodes to the graph, regardless of type, for processing later
        nx_graph.add_node(node['id'], **node)
    for edge in edges_to_keep:
        nx_graph.add_edge(edge['from'], edge['to'], **{k: v for k, v in edge.items() if k not in ['from', 'to']})

    # Calculate graph metrics
    degree_centrality = nx.degree_centrality(nx_graph)
    betweenness_centrality = nx.betweenness_centrality(nx_graph)
    closeness_centrality = nx.closeness_centrality(nx_graph)

    # Try to compute eigenvector centrality with error handling
    try:
        eigenvector_centrality = nx.eigenvector_centrality(nx_graph, max_iter=500)
    except nx.PowerIterationFailedConvergence:
        print("Eigenvector centrality calculation failed to converge.")
        eigenvector_centrality = {}

    modularity_class = {node: i for i, community in enumerate(nx.algorithms.community.greedy_modularity_communities(nx_graph)) for node in community}
    local_clustering_coefficient = nx.clustering(nx_graph)

    # Find root nodes (non-numeric names) and create a mapping for concatenation
    root_node_names = {node for node in nx_graph.nodes if not node.isdigit()}

    data_of_nodes = []
    for node, data in nx_graph.nodes(data=True):
        # Remove nodes with non-numeric names
        if node.isdigit():
            # Get the root node connected to the process node
            root_node = next(
                (root_node for root_node in root_node_names
                if nx_graph.has_edge(root_node, node)),
                None
            )
            if root_node:
                label = f"{root_node} ({node})"
            else:
                label = node

            if not nx.is_connected(nx_graph.to_undirected()):
                print("The graph is not connected. Eigenvector centrality may not be calculated correctly.")

            data_of_nodes.append((
                label,
                nx_graph.degree[node],
                degree_centrality.get(node, 0),
                betweenness_centrality.get(node, 0),
                closeness_centrality.get(node, 0),
                eigenvector_centrality.get(node, 0),
                modularity_class.get(node, 'Unknown'),
                local_clustering_coefficient.get(node, 0)
            ))

    generate_data_end_time = time.time()

    #for line in data_of_nodes:
    #    print(line)
    print(f"[+] Generated data in {generate_data_end_time - generate_data_start_time:.4f} seconds")

    output_path3 = os.path.join("data_of_graphs", f"data_of_{root_name.replace('.exe', '').lower()}_process_network_graph.txt")

    with open(output_path3, 'w') as file:
        header = "Label, Degree, Degree Centrality, Betweenness, Closeness, Eigenvector, Modularity, Local Clustering"
        file.write(f"{header}\n")
        for line in data_of_nodes:
            file.write(f"{line}\n")

def extract_root_nodes_with_multiple_process_nodes(min_count=2):
    """Extract root nodes connected to more than min_count process nodes."""
    print(f"[i] Extracting root nodes with more than {min_count} process nodes...")
    result = []
    
    for root_node in G_process_grouped.nodes:
        if G_process_grouped.nodes[root_node].get('node_type') == 'root_node':
            connected_process_nodes = [n for n in G_process_grouped.neighbors(root_node)
                                       if G_process_grouped.nodes[n].get('node_type') == 'process_node']
            if len(connected_process_nodes) > min_count:
                result.append(root_node)
    
    #print(f"Root nodes with more than {min_count} process nodes: {result}")
    return result

def run_git_commands():
    """Run git add, git commit, and git push commands in sequence."""
    try:
        # Run git add .
        print("[i] Running 'git add .\\graphs\\'...")
        subprocess.run(["git", "add", ".\\graphs\\"], check=True)
        
        # Run git commit -m "default"
        print("[i] Running 'git commit -m \"System Scan Commit\"'...")
        subprocess.run(["git", "commit", "-m", "default"], check=True)
        
        # Run git push
        print("[i] Running 'git push'...")
        subprocess.run(["git", "push"], check=True)
        
        print("[i] Git commands executed successfully.")
    
    except subprocess.CalledProcessError as e:
        print(f"[#] An error occurred: {e}")

def run_python_script(script_path):
    """Run the specified Python script."""
    try:
        # Ensure the script path is absolute
        script_path = os.path.abspath(script_path)
        print(f"[i] Running {update_data_script_path}...")
        
        # Run the Python script
        result = subprocess.run(["python", script_path], capture_output=True, text=True, check=True)
        
        # Print output and errors (if any)
        #print("Output:\n", result.stdout)
        
        print(f"[+] Successfully executed {update_data_script_path}")
    
    except subprocess.CalledProcessError as e:
        print(f"[#] An error occurred while running {script_path}: {e}")

if __name__ == "__main__":
    dataset_path = os.path.join("..", "list_MODULES_imports.txt")
    update_data_script_path = "updating_dataset.py"  # Replace with the path to your target script

    while True:
        os.system("cls")

        #run_python_script(update_data_script_path)

        print(f'[+] begin html generation')
        filter_by_process_root = ''
        reading_dataset(dataset_path)
        initializing_graph()
        generated_for_this_root_nodes = extract_root_nodes_with_multiple_process_nodes(min_count=2)

        for root_name in generated_for_this_root_nodes:
            output_path1 = os.path.join("graphs", f"undirected_{root_name.replace('.exe', '').lower()}_process_network_graph.html")
            generate_pyvis_html(output_path1, root_name.replace('.exe', ''))
            output_path2 = os.path.join("graphs", f"directed_{root_name.replace('.exe', '').lower()}_process_network_graph.html")
            generate_directed_pyvis_html(output_path2, root_name.replace('.exe', ''))
        #run_git_commands()

        print(f'[i] {timer_for_update} seconds timer begin')
        time.sleep(timer_for_update) #Seconds
        