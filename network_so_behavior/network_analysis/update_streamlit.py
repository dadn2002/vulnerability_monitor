from pyvis.network import Network
import matplotlib.colors as mcolors
import random
import networkx as nx
import os
import subprocess
import time
import re

modules_of_processes = []
G_process_grouped = nx.Graph()
timer_for_update = 60

def reading_dataset(file_path):
    """Read dataset and populate modules_of_processes list."""
    print("[i] Reading dataset...")
    with open(file_path, "r") as file:
        modules_of_processes.extend(line.strip() for line in file)

def get_handles_directed_edge_list(root_process_name):
    handles_data_txt = f"..\\handles_data\\handles_to_{root_process_name.lower()}.txt"

    with open(handles_data_txt, 'r') as file:
        text = file.read()
    
    pattern_edge1 = re.compile(r'pid: (\d+)')
    pattern_edge2 = re.compile(r'(\(\d+\))')        

    lines = text.split('\n')

    main_handle_node = ''
    list_has_handle_to_node = []
    edges = []

    for line in lines:
        # Search for the first pattern (edge1)
        match1 = pattern_edge1.search(line)
        if match1:
            if main_handle_node:
                # Create edges from the last main_handle_node to all nodes in list_has_handle_to_node
                for node in list_has_handle_to_node:
                    edges.append((main_handle_node, node))
            # Set the new handle node and clear the list for the next set of edges
            main_handle_node = match1.group(1)
            list_has_handle_to_node.clear()
        
        # Search for the second pattern (edge2)
        match2 = pattern_edge2.search(line)
        if match2:
            # Add the process node to the list, removing parentheses
            list_has_handle_to_node.append(match2.group(1).replace('(', '').replace(')', ''))
    
    # After processing all lines, add remaining edges
    if main_handle_node:
        for node in list_has_handle_to_node:
            edges.append((main_handle_node, node))

    return edges

def initializing_graph():
    """Initialize the graph from the dataset."""
    print("[i] Initializing nx graph...")
    colors = list(mcolors.CSS4_COLORS.keys())
    random.shuffle(colors)
    color_map = {}

    for node in modules_of_processes:
        if '),' in node:
            try:
                separated_names = node.split('), ')
                process_name = separated_names[0].split(' (')[0]
                PID_number = separated_names[0].split(' (')[1]
                dll_name = separated_names[1].lower().split('.dll')[0]

                if '.exe' in dll_name:
                    continue

                if process_name not in color_map:
                    color_map[process_name] = colors.pop()

                if not G_process_grouped.has_node(process_name):
                    G_process_grouped.add_node(process_name, title=process_name, node_type='root_node', color=color_map[process_name])

                if not G_process_grouped.has_node(dll_name):
                    G_process_grouped.add_node(dll_name, title=dll_name, node_type='dll_node')

                if not G_process_grouped.has_node(PID_number):
                    G_process_grouped.add_node(PID_number, title=PID_number, node_type='process_node', color=color_map[process_name])

                G_process_grouped.add_edge(process_name, PID_number, color=color_map[process_name])
                G_process_grouped.add_edge(PID_number, dll_name, color=color_map[process_name])
            
            except IndexError as e:
                print(f"[#] Error processing line: {node}")
                print(f"[#] Exception: {e}")
                continue  # Skip to the next line

    pos = nx.spring_layout(G_process_grouped)  # Use spring_layout or any other available layout function
    
    # Draw nodes and edges
    for node_type, color in [('root_node', 'color'), ('process_node', 'color'), ('dll_node', 'lightgrey')]:
        nodes = [node for node, data in G_process_grouped.nodes(data=True) if data.get('node_type') == node_type]
        node_colors = [G_process_grouped.nodes[node].get('color', color) for node in nodes]
        sizes = {'root_node': 5000, 'process_node': 2000, 'dll_node': 1250}
        nx.draw_networkx_nodes(G_process_grouped, pos, nodelist=nodes, node_color=node_colors, node_size=sizes[node_type])

    edge_colors = [G_process_grouped[u][v]['color'] for u, v in G_process_grouped.edges]
    nx.draw_networkx_edges(G_process_grouped, pos, edgelist=G_process_grouped.edges, edge_color=edge_colors, width=1.5)
    nx.draw_networkx_labels(G_process_grouped, pos, font_size=8, font_weight='bold', font_color='black')

    print(f"[+] Generated networkx graph")
    print(f"[i] Number of nodes: {len(G_process_grouped.nodes)}")
    print(f"[i] Number of edges: {len(G_process_grouped.edges)}")

def generate_pyvis_html(output_path, filter_by_process_root):
    """Generate Pyvis HTML visualization."""
    print("[i] Generating pyvis HTML...")

    def random_color():
        """Generate a vibrant random color in hex format."""
        return f'#{random.randint(0, 0xFFFFFF):06x}'

    def generate_node_color(root_color):
        """Generate a color for process nodes based on the root color."""
        r, g, b = [int(root_color[i:i+2], 16) for i in (1, 3, 5)]
        r = min(255, max(0, r + random.randint(-50, 50)))
        g = min(255, max(0, g + random.randint(-50, 50)))
        b = min(255, max(0, b + random.randint(-50, 50)))
        return f'#{r:02x}{g:02x}{b:02x}'

    pyvis_net = Network(height='1000px', width='100%', bgcolor='#222222', font_color='white')

    # Get the root node using the provided filter
    root_node = next((node for node in G_process_grouped.nodes if G_process_grouped.nodes[node].get('node_type') == 'root_node' and filter_by_process_root in node), None)

    if not root_node:
        print(f"No root nodes found with filter: {filter_by_process_root}")
        return

    color_map = {root_node: random_color()}

    nodes_to_keep = set()
    edges_to_keep = set()

    # Collect nodes and edges related to the root node
    nodes_to_keep.add(root_node)
    for neighbor in G_process_grouped.neighbors(root_node):
        nodes_to_keep.add(neighbor)
        edges_to_keep.update((root_node, neighbor))
        for dll_neighbor in G_process_grouped.neighbors(neighbor):
            if G_process_grouped.nodes[dll_neighbor].get('node_type') == 'dll_node':
                nodes_to_keep.add(dll_neighbor)
                edges_to_keep.add((neighbor, dll_neighbor))

    subgraph = G_process_grouped.subgraph(nodes_to_keep)
    pyvis_net.from_nx(subgraph)

    pyvis_net.force_atlas_2based()
    pyvis_net.set_options("""
    var options = {
        "nodes": {
            "size": 30,
            "font": {
                "size": 20,
                "align": "center"
            }
        },
        "edges": {
            "color": {
                "inherit": false
            },
            "smooth": {
                "enabled": true
            },
            "width": 2
        },
        "physics": {
            "enabled": true,
            "barnesHut": {
                "gravitationalConstant": -20000,
                "centralGravity": 0.3,
                "springLength": 200,
                "springConstant": 0.04
            }
        }
    }
    """)

    for node in pyvis_net.nodes:
        node_id = node['id']
        node_type = G_process_grouped.nodes[node_id].get('node_type')
        if node_type == 'root_node':
            node['color'] = color_map.get(node_id, random_color())
            node['size'] = 50
        elif node_type == 'process_node':
            root_node_color = color_map.get(root_node, random_color())
            node['color'] = generate_node_color(root_node_color)
            node['size'] = 30
        else:  # dll_node
            node['color'] = '#808080'
            node['size'] = 20
        
        node['label'] = node_id
        node['font'] = {'size': 16, 'color': 'white', 'align': 'center'}

    for edge in pyvis_net.edges:
        u, v = edge['from'], edge['to']
        edge['color'] = G_process_grouped[u][v].get('color', '#FFFFFF')

    #pyvis_net.write_html(output_path)
    print(f"[+] Created: {output_path}")

def generate_directed_pyvis_html(output_path, filter_by_process_root=None):
    """Generate Directed Pyvis HTML visualization."""
    print("[i] Generating pyvis HTML...")

    def random_color():
        """Generate a vibrant random color in hex format."""
        return f'#{random.randint(0, 0xFFFFFF):06x}'

    def generate_node_color(root_color):
        """Generate a color for process nodes based on the root color."""
        r, g, b = [int(root_color[i:i+2], 16) for i in (1, 3, 5)]
        r = min(255, max(0, r + random.randint(-50, 50)))
        g = min(255, max(0, g + random.randint(-50, 50)))
        b = min(255, max(0, b + random.randint(-50, 50)))
        return f'#{r:02x}{g:02x}{b:02x}'

    # Initialize the Pyvis Network
    pyvis_net = Network(height='1000px', width='100%', bgcolor='#222222', font_color='white', directed=True)

    color_map = {}
    nodes_to_keep = set()
    edges_to_keep = set()

    if filter_by_process_root:
        # Get the root node using the provided filter
        root_node = next((node for node in G_process_grouped.nodes if G_process_grouped.nodes[node].get('node_type') == 'root_node' and filter_by_process_root in node), None)

        if not root_node:
            print(f"No root nodes found with filter: {filter_by_process_root}")
            return

        # Get directed edge list for the root node
        directed_edges = get_handles_directed_edge_list(filter_by_process_root)
        directed_edges = [(str(edge[0]), str(edge[1])) for edge in directed_edges]  # Ensure edges are in string format

        color_map[root_node] = random_color()

        wait = input('pause')

        # Collect nodes and edges related to the root node
        for neighbor in G_process_grouped.neighbors(root_node):
            if G_process_grouped.nodes[neighbor].get('node_type') == 'process_node':
                nodes_to_keep.add(neighbor)
                edges_to_keep.add((root_node, neighbor))
                
        # Collect nodes and edges related to the process handles edges
        for u, v in directed_edges:
            # Ensure the destination node is valid
            if v not in G_process_grouped.nodes:
                continue
            
            nodes_to_keep.add(v)  # Add the process_node (v)
            
            # Find and add root nodes of the process nodes
            neighbors_list = list(G_process_grouped.neighbors(v))  # Make a list of neighbors
            for neighbor in neighbors_list:
                if G_process_grouped.nodes[neighbor].get('node_type') == 'root_node':
                    nodes_to_keep.add(neighbor)
                    if G_process_grouped.has_edge(neighbor, v):
                        G_process_grouped.remove_edge(neighbor, v)
                    edges_to_keep.add((neighbor, v))  # Add edge from root_node to process_node

        # Include directed edges in edges_to_keep
        edges_to_keep.update(directed_edges)

        # Create a subgraph with the nodes and edges to keep
        subgraph = G_process_grouped.subgraph(nodes_to_keep)
        pyvis_net.from_nx(subgraph)

        # Add edges to the Pyvis network
        for u, v in edges_to_keep:
            if u in subgraph.nodes and v in subgraph.nodes:
                edge_color = '#FF0000' if (u, v) in directed_edges else '#FFFFFF'
                pyvis_net.add_edge(u, v, color=edge_color)  # Set default edge color if needed

    else:
        # No filter provided, include all process nodes and their connections
        directed_edges = set()  # Initialize directed_edges to an empty set for consistency
        for node in G_process_grouped.nodes:
            if G_process_grouped.nodes[node].get('node_type') == 'process_node':
                nodes_to_keep.add(node)
                for neighbor in G_process_grouped.neighbors(node):
                    if G_process_grouped.nodes[neighbor].get('node_type') in {'process_node', 'dll_node'}:
                        #nodes_to_keep.add(neighbor)
                        #edges_to_keep.add((node, neighbor))
                        pass

        # Create a subgraph with the nodes and edges to keep
        subgraph = G_process_grouped.subgraph(nodes_to_keep)
        pyvis_net.from_nx(subgraph)

        # Add edges to the Pyvis network
        for u, v in edges_to_keep:
            if u in subgraph.nodes and v in subgraph.nodes:
                edge_color = '#FFFFFF'  # Use default edge color as there are no specific directed edges
                pyvis_net.add_edge(u, v, color=edge_color)

    pyvis_net.force_atlas_2based()
    pyvis_net.set_options("""
    var options = {
        "nodes": {
            "size": 30,
            "font": {
                "size": 20,
                "align": "center"
            }
        },
        "edges": {
            "color": {
                "inherit": false
            },
            "smooth": {
                "enabled": true
            },
            "width": 2
        },
        "physics": {
            "enabled": true,
            "barnesHut": {
                "gravitationalConstant": -20000,
                "centralGravity": 0.3,
                "springLength": 200,
                "springConstant": 0.04
            }
        }
    }
    """)

    for node in pyvis_net.nodes:
        node_id = node['id']
        node_type = G_process_grouped.nodes[node_id].get('node_type')
        if node_type == 'root_node':
            node['color'] = color_map.get(node_id, random_color())
            node['size'] = 50
        elif node_type == 'process_node':
            root_node_color = color_map.get(node_id, random_color())
            node['color'] = generate_node_color(root_node_color)
            node['size'] = 30
        else:  # dll_node
            node['color'] = '#808080'
            node['size'] = 20
        
        node['label'] = node_id
        node['font'] = {'size': 16, 'color': 'white', 'align': 'center'}

    # Write the HTML to the output path
    pyvis_net.write_html(output_path)
    print(f"[+] Created: {output_path}")

def extract_root_nodes_with_multiple_process_nodes(min_count=2):
    """Extract root nodes connected to more than min_count process nodes."""
    print(f"[i] Extracting root nodes with more than {min_count} process nodes...")
    result = []
    
    for root_node in G_process_grouped.nodes:
        if G_process_grouped.nodes[root_node].get('node_type') == 'root_node':
            connected_process_nodes = [n for n in G_process_grouped.neighbors(root_node)
                                       if G_process_grouped.nodes[n].get('node_type') == 'process_node']
            if len(connected_process_nodes) > min_count:
                result.append(root_node)
    
    #print(f"Root nodes with more than {min_count} process nodes: {result}")
    return result

def run_git_commands():
    """Run git add, git commit, and git push commands in sequence."""
    try:
        # Run git add .
        print("[i] Running 'git add .\\graphs\\'...")
        subprocess.run(["git", "add", ".\\graphs\\"], check=True)
        
        # Run git commit -m "default"
        print("[i] Running 'git commit -m \"System Scan Commit\"'...")
        subprocess.run(["git", "commit", "-m", "default"], check=True)
        
        # Run git push
        print("[i] Running 'git push'...")
        subprocess.run(["git", "push"], check=True)
        
        print("[i] Git commands executed successfully.")
    
    except subprocess.CalledProcessError as e:
        print(f"[#] An error occurred: {e}")

def run_python_script(script_path):
    """Run the specified Python script."""
    try:
        # Ensure the script path is absolute
        script_path = os.path.abspath(script_path)
        print(f"[i] Running {update_data_script_path}...")
        
        # Run the Python script
        result = subprocess.run(["python", script_path], capture_output=True, text=True, check=True)
        
        # Print output and errors (if any)
        #print("Output:\n", result.stdout)
        
        print(f"[+] Successfully executed {update_data_script_path}")
    
    except subprocess.CalledProcessError as e:
        print(f"[#] An error occurred while running {script_path}: {e}")

if __name__ == "__main__":
    dataset_path = os.path.join("..", "list_MODULES_imports.txt")
    update_data_script_path = "updating_dataset.py"  # Replace with the path to your target script

    while True:
        os.system("cls")

        #run_python_script(update_data_script_path)

        print(f'[+] begin html generation')
        filter_by_process_root = ''
        reading_dataset(dataset_path)
        initializing_graph()
        generated_for_this_root_nodes = extract_root_nodes_with_multiple_process_nodes(min_count=2)

        for root_name in generated_for_this_root_nodes:
            output_path1 = os.path.join("graphs", f"filtered_{root_name.replace('.exe', '').lower()}_process_network_graph.html")
            generate_pyvis_html(output_path1, root_name.replace('.exe', ''))
            output_path2 = os.path.join("graphs", f"directed_{root_name.replace('.exe', '').lower()}_process_network_graph.html")
            generate_directed_pyvis_html(output_path2, root_name.replace('.exe', ''))
        #run_git_commands()
        output_path3 = os.path.join("graphs", f"directed_global_process_network_graph.html")
        generate_directed_pyvis_html(output_path3)

        print(f'[i] {timer_for_update} seconds timer begin')
        time.sleep(timer_for_update) #Seconds
        