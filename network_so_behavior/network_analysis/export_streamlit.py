import streamlit as st
import streamlit.components.v1 as components
import os
import glob

def get_graph_name_from_path(path: str, graph_type: str) -> str:
    basename = os.path.basename(path)
    prefix = f'{graph_type}_'
    suffix = '_process_network_graph.html'
    
    if basename.startswith(prefix) and basename.endswith(suffix):
        return basename[len(prefix):-len(suffix)]
    return ''

#------------------------------Scene Management-------------------------#
def next_scene():
    st.session_state.scene += 1
    st.session_state.refresh_graph = True  # Trigger graph update

def reset_scene():
    st.session_state.scene = 1
    st.session_state.refresh_graph = True  # Trigger graph update

def show_buttons():
    if st.session_state.scene < highest_scene:
        if st.button("Continue"):
            next_scene()
            st.rerun()  # Just as simple as it seems
    elif st.session_state.scene == highest_scene:
        if st.button("Reset"):
            reset_scene()
            st.rerun()  # My brain is melting... Time for dwarf fortress 
                                    # I just lost like 3 hours before finding this function
                                    # maybe reading the documentation makes things easier....

#------------------------------Variables part---------------------------#
folder_path = os.path.join(os.path.dirname(__file__), 'graphs')
pattern = os.path.join(folder_path, '*_process_network_graph.html')
html_paths = glob.glob(pattern)

# Define available graph types
graph_types = ["undirected", "directed"]
default_graph_type = "undirected"

# Initialize session state for scene management
if 'scene' not in st.session_state:
    st.session_state.scene = 1
if 'selected_graph' not in st.session_state:
    st.session_state.selected_graph = "dllhost"
if 'selected_graph_type' not in st.session_state:
    st.session_state.selected_graph_type = default_graph_type
if 'refresh_graph' not in st.session_state:
    st.session_state.refresh_graph = False

highest_scene = 3

#------------------------------Scenes------------------------------------#
st.title('Vulnerability Monitor')

if st.session_state.scene == 1:
    st.markdown("Acompanhe este projeto em: https://github.com/dadn2002/vulnerability_monitor")
    st.markdown("## Apresentação\n\n")
    st.markdown("""
                 A um certo tempo atrás fui apresentado a um projeto da universidade que tinha como
                objetivo finalizar uma disciplina sobre analise de redes, juntando os conhecimentos
                sobre as bibliotecas networkx, pyvis, a ferramenta de visualização gephi e agora a
                de 'exportação' streamlit. Os critérios de avaliação da atividade porém, não limita-
                vam a temática do trabalho, um agradecimento ao professor responsável pela discipli-
                na Patrick Terremate pela liberdade, o que permitiu uma junção de outra área que es-
                tou a estudar diariamente: a Cybersecurity. Dentre alguns problemas que enfrentei 
                nos últimos meses o problema grave quanto a falta de documentação de fácil acesso da
                microsoft e as diversas formas de proteção existentes que impedem muitas das ideias
                tentadas se mostrou persistente... Parecendo até mesmo como uma batalha pra conse-
                guir burlar as ferramentas, seja reescrevendo funções da ntdll, obscuração, fileless
                programs, encriptografia, hooks, virtualização e afins... Uma técnica simples de pro-
                teção se destacou, alguns programas bloqueam modificação de outros programas, através
                do que chamamos de handles. E curiosamente não existe uma maneira fácil de observarmos
                quais programas dependendem de quais, o task manager apenas mostra quantos handles um
                PID tem e o comando tasklist precisa de uma modificação gigantesca só pra poder apre-
                sentar handles que possam de alguma forma levar a alguma coisa... Em contra-partida, 
                no linux o simples fuser <filename> parece realizar pirotecnia por tão simples, ainda
                que a microsoft ofereça um programa que realiza a mesma função no Sysinternals, o 
                handle.exe que não precisamos nem pesquisar muito pra saber que não é código aberto.
                Tentar realizar a leitura dos handles de um PID tomaram vários dias de minha vida e
                a quantidade de MALFORMED_HANDLE e DENIED_ACCESS que encheram minha tela me levaram 
                quase a insanidade e fizeram esse esforço todo ganhar um peso bem maior. O que origi-
                nalmente seria um monitor de simples dll's e chamadas de funções ganhou uma faceta
                bastante interessante, ainda que a parte referente a plotar as calls de dll's esteja
                bem longe de estar pronto (Aparentemente PatchGuard faz questão de fechar tudo oq faço
                e ainda não pensei numa forma mais inteligente de monitorar funções sem correr o risco
                de corromper o SO), a análise dos process handles já está apresentando resultados 
                o suficiente para me fazer escrever este texto! 

                 Iremos começar então o trabalho apresentando os métodos para coleta de dados, passando
                pelo que foi tentado, por que deu errado e o que milagrosamente funcionou e foi aplicado.
                Seguiremos com as análises estáticas das medidas usuais de grafos com os estáticos gera-
                dos por networkx e ao final trataremos da parte visual gerada pelo pyvis.
                """)

    show_buttons()

elif st.session_state.scene == 2:
    st.markdown(f"Potatoes")
    show_buttons()

elif st.session_state.scene == highest_scene:
    # Create a selectbox for choosing the graph type
    default_index_type = graph_types.index(st.session_state.selected_graph_type) if st.session_state.selected_graph_type in graph_types else 0
    selected_graph_type = st.selectbox('Select a graph type to view:', graph_types, index=default_index_type, key='selected_graph_type')

    # Update session state with selected graph type
    if st.session_state.selected_graph_type != selected_graph_type:
        st.session_state.selected_graph_type = selected_graph_type
        st.session_state.selected_graph = None  # Reset selected graph to ensure proper update
        st.session_state.refresh_graph = True
        st.rerun()  # Trigger a rerun to update the graph

    # Filter graph names based on the selected graph type
    graph_names = list(set(get_graph_name_from_path(path, selected_graph_type) for path in html_paths if selected_graph_type in path))
    graph_names = [name for name in graph_names if name]

    # If the current selected graph is not available in the new graph type, reset to default
    if st.session_state.selected_graph not in graph_names and graph_names:
        st.session_state.selected_graph = "dllhost" if "dllhost" in graph_names else graph_names[0]

    # Select the graph
    selected_graph = st.selectbox('Select a graph to view:', graph_names, index=graph_names.index(st.session_state.selected_graph) if st.session_state.selected_graph in graph_names else 0, key='selected_graph')

    # Update session state with selected graph
    if selected_graph and st.session_state.selected_graph != selected_graph:
        st.session_state.selected_graph = selected_graph
        st.session_state.refresh_graph = True
        st.rerun()  # Trigger a rerun to update the graph

    # Display the selected graph
    if st.session_state.selected_graph and st.session_state.refresh_graph:
        selected_path = None
        for path in html_paths:
            if get_graph_name_from_path(path, selected_graph_type) == st.session_state.selected_graph:
                selected_path = path
                st.session_state.selected_old_graph = st.session_state.selected_graph
                break
        
        if selected_path:
            st.write(f"Displaying {selected_graph_type} graph of process: {st.session_state.selected_graph}")
            with open(selected_path, 'r') as file:
                html_content = file.read()
            components.html(html_content, height=600)
            st.session_state.refresh_graph = False  # Reset the display flag after rendering

    show_buttons()
