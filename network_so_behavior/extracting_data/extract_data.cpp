
#include "../../imports.h"
#include "functions_header.h"
//#include <windows.h>

/*  Compiling instructions
        g++ -c main.cpp -o main.o
        g++ -c menu_functions.cpp -o menu_functions.o
        g++ main.o menu_functions.o -o main.exe
*/

/*  Notes
        Running this .exe in new computers trigger windows defender or something
        Probably related to complete scan of PIDs and info about them which is kinda suspicious ngl
*/

//  Shared variables
bool debugEnabled = false;
const char* list_of_ignored_processes[] = {"extract_data.exe", "[System Process]"};

// Saddly i could only think of redefining my macro :(
#undef debug
#define debug(msg, ...) do { if (debugEnabled) printf("[%] " msg "\n", ##__VA_ARGS__); } while (0)

void EnableDebugPrivilege() {
    HANDLE hToken;
    LUID luid;
    TOKEN_PRIVILEGES tkp;

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) {
        warn("[OpenProcessToken] failed. Error: %lx", GetLastError());
        return;
    }

    if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &luid)) {
        warn("[LookupPrivilegeValue] failed. Error: %lx", GetLastError());
        CloseHandle(hToken);
        return;
    }

    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Luid = luid;
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    if (!AdjustTokenPrivileges(hToken, FALSE, &tkp, sizeof(tkp), NULL, NULL)) {
        warn("[AdjustTokenPrivileges] failed. Error: %lx", GetLastError());
        CloseHandle(hToken);
        return;
    }

    if (GetLastError() == ERROR_NOT_ALL_ASSIGNED) {
        warn("The token does not have the specified privilege. Error: %lx", GetLastError());
    } else {
        okay("SeDebugPrivilege enabled.");
    }

    CloseHandle(hToken);
}

bool contains_exe(const char* str) {
    return strstr(str, ".exe") != nullptr;
}

HANDLE attempt_get_handle_to_process(int PID, DWORD permissions) {

    HANDLE hProcess = OpenProcess(permissions, FALSE, PID);
    if (!hProcess){
        warn("[OpenProcess] failed to access %d, Error: %lx", PID, GetLastError());
        return nullptr;
    }
    return hProcess;
}

char** GetAllImportTable(DWORD PID, const char* process_name){
    HANDLE hProcess = attempt_get_handle_to_process(PID, )
}

char** GetAllModulesInfoOfPID(DWORD PID, int* numModules) {
    //CreateToolHelp32Snapshot is powerfull
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, PID);
    if (hSnapshot == INVALID_HANDLE_VALUE) {
        switch (GetLastError()){
            case 5:
                warn("PID: %-6d, Denied Access", PID);
                break;
            case 299:
                warn("PID: %-6d, Error Memory Management", PID);
                break;
            default:
                warn("PID: %-6d, [CreateToolhelp32Snapshot] failed to get handle, Error: %lx", GetLastError());
                break;
        }
        *numModules = 0;
        return nullptr;
    }

    MODULEENTRY32 moduleEntry;
    moduleEntry.dwSize = sizeof(MODULEENTRY32);

    int count = 0;
    if (Module32First(hSnapshot, &moduleEntry)) {
        do {
            ++count;
        } while (Module32Next(hSnapshot, &moduleEntry));
    }

    char** moduleNames = new char*[count];
    int index = 0;

    // Reset snapshot to beginning
    Module32First(hSnapshot, &moduleEntry);

    if (!Module32First(hSnapshot, &moduleEntry)) {
        warn("PID: %-6d, [Module32First] failed to get module info, Error: %lx", PID, GetLastError());
        CloseHandle(hSnapshot);
        return nullptr;
    }
    do {
        moduleNames[index] = new char[MAX_MODULE_NAME32];
        strncpy(moduleNames[index], moduleEntry.szModule, MAX_MODULE_NAME32 - 1);
        moduleNames[index][MAX_MODULE_NAME32 - 1] = '\0';
        if (index == 0){
            debug("Name of module: %s", moduleEntry.szModule);
        }
        ++index;
        //Remember to place here the import/export table

        //info("  %s", moduleEntry.szModule);
        //info("Module name: %s", moduleEntry.szModule);
        //info("Executable path: %s", moduleEntry.szExePath);
        //info("Base address: 0x%p", (void*)moduleEntry.modBaseAddr);
        //info("Module size: %lu bytes\n", moduleEntry.modBaseSize);
    } while (Module32Next(hSnapshot, &moduleEntry));

    CloseHandle(hSnapshot);
    *numModules = count;
    okay("PID: %-6d, Granted Access", PID);
    return moduleNames;
}

void free_module_names(char** moduleNames, int numModules) {
    
    if (moduleNames) {
        for (int i = 0; i < numModules; ++i) {
            delete[] moduleNames[i];
        }
        delete[] moduleNames;
    }
}

BOOL write_data_in_nx_format(ProcessInfo *processList, int numProcesses) {
    // Write List of PIDs in networkx format
    FILE* outputFile = fopen("../list_PIDs.txt", "w");
    if (!outputFile) {
        fprintf(stderr, "Error opening file for writing!\n");
        warn("[fopen] failed to open file. Error: %lx", GetLastError());
        return false;
    }

    if (processList) {
        info("Writing in list_PIDs:");
        for (int i = 0; i < numProcesses; i++) {
            //const char* temp_line = <reinterpret_cast>(char*)processList[i].pid;
            fprintf(outputFile, "%s (%d)\n", processList[i].processName, processList[i].pid); 
        }
    } else { return false; }

    fclose(outputFile);
    okay("Operation Success!");
    //return TRUE;

    //goto skipItAll;
    // Write edges from PIDs to MODULES in networkx format
    outputFile = fopen("../list_MODULES_imports.txt", "w");
    if (!outputFile) {
        fprintf(stderr, "Error opening file for writing!\n");
        warn("[fopen] failed to open file. Error: %lx", GetLastError());
        return false;
    }

    if (processList) {
        info("Writing in list_MODULES_imports:");
        for (int i = 0; i < numProcesses; i++) {
            int numModules = 0;
            char** moduleNames = GetAllModulesInfoOfPID(processList[i].pid, &numModules);
            if (moduleNames) {
                // If you call get_all_modules_info_of_PID and GetRDataSectionBaseAddress it'll denies access magically
                for (int j = 0; j < numModules; ++j) {
                    fprintf(outputFile, "%s (%d), %s\n", moduleNames[0], processList[i].pid, moduleNames[j]);
                }
                free_module_names(moduleNames, numModules);
            } else {
                //pass
            }
        }
    } else { return false; }

    fclose(outputFile);
    okay("Operation Success!");
    //skipItAll:

    return true;
}

void SetupDebugMode(int argc, char* argv[]) {
    
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "-debug") == 0) {
            debugEnabled = true;
            okay("Debug mode enabled.\n");
        }
    }
}

ProcessInfo* print_all_PIDs(int *numProcesses) {
    // Create snapshot of all running processes
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE) {
        warn("[CreateToolhelp32Snapshot] failed to create snapshot. Error: %lx\n", GetLastError());
        *numProcesses = 0;
        return NULL;
    }

    PROCESSENTRY32 processEntry;
    processEntry.dwSize = sizeof(PROCESSENTRY32);

    if (!Process32First(hSnapshot, &processEntry)) {
        warn("[Process32First] failed to get first process. Error: %lx\n", GetLastError());
        CloseHandle(hSnapshot);
        *numProcesses = 0;
        return NULL;
    }

    int initialSize = 256;
    ProcessInfo *processList = (ProcessInfo*)malloc(initialSize * sizeof(ProcessInfo));
    if (processList == NULL) {
        warn("[malloc] allocation failed. Error: %lx\n", GetLastError());
        CloseHandle(hSnapshot);
        *numProcesses = 0;
        return NULL;
    }

    int currentSize = 0;

    do {
        if (currentSize >= initialSize) {
            initialSize *= 2;
            ProcessInfo *temp = (ProcessInfo *)realloc(processList, initialSize * sizeof(ProcessInfo));
            if (temp == NULL) {
                warn("[realloc] reallocation failed. Error: %lx\n", GetLastError());
                free(processList);
                CloseHandle(hSnapshot);
                *numProcesses = 0;
                return NULL;
            }
            processList = temp;
        }

        BOOL must_skip_this_process = false;
        for (int i = 0; i < sizeof(list_of_ignored_processes)/sizeof(list_of_ignored_processes[0]); i++){
            if (strcmp(processEntry.szExeFile, list_of_ignored_processes[i]) == 0){
                debug("Skipped %s", processEntry.szExeFile);
                must_skip_this_process = true;
            }
        }
        if (must_skip_this_process){ continue; }

        processList[currentSize].pid = processEntry.th32ProcessID;
        strncpy(processList[currentSize].processName, processEntry.szExeFile, MAX_NAME_LENGTH - 1);
        processList[currentSize].processName[MAX_NAME_LENGTH - 1] = '\0'; // Ensure null termination
        currentSize++;
    } while (Process32Next(hSnapshot, &processEntry));

    CloseHandle(hSnapshot);
    *numProcesses = currentSize;
    return processList;
}

int mainRoutine() {

    //int useThisPID;
    //info("Insert PID");
    //scanf("%d", &useThisPID);
    //print_from_PID_all_modules_info(useThisPID);
    int numProcesses;
    ProcessInfo* processList = print_all_PIDs(&numProcesses);

    if (processList != NULL) {
        info("List of Processes:\n");
        for (int i = 0; i < numProcesses; i++) {
            info("PID: %-6d, Process Name: %s", processList[i].pid, processList[i].processName);

            /*
                int numModules = 0;
                char** moduleNames = get_all_modules_info_of_PID(processList[i].pid, &numModules);
                if (moduleNames) {
                    for (int i = 0; i < numModules; ++i) {
                        info("  %s", moduleNames[i]);
                    }

                    free_module_names(moduleNames, numModules);
                } else {
                    warn("Failed to retrieve module names for PID %d", processList[i].pid);
                }
            */
        }
    } else {
        warn("Failed to retrieve list of processes");
    }

    write_data_in_nx_format(processList, numProcesses);

    free(processList);
    return 0;
}

int main(int argc, char* argv[]) {

    system("cls");
    SetupDebugMode(argc, argv);

    EnableDebugPrivilege();

    // Run the main routine in the main thread
    mainRoutine();

    return 0;
}