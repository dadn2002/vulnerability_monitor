#include "../imports.h"
#include "functions_header.h"

#include <cstdio>
#include <thread>
#include <atomic>
#include <csignal>

/*  Compiling instructions
        g++ -c main.cpp -o main.o
        g++ -c menu_functions.cpp -o menu_functions.o
        g++ main.o menu_functions.o -o main.exe
*/

//  Shared variable and synchronization object
std::atomic<bool> shutdownProgram(false);
volatile int sharedVariable = 0;
int running_mode = 0;
ListOfTrackedPIDs list_of_tracked_PIDs[1024];
HANDLE hExampleFunction;
ListOfCountersOfProcNames GlobalFunctionsCounter[1024];
bool debugEnabled = false;

// Saddly i could only think of redefining my macro :(
#undef debug
#define debug(msg, ...) do { if (debugEnabled) printf("[%] " msg "\n", ##__VA_ARGS__); } while (0)

void signalHandler(int signal) {
    if (signal == SIGINT) {
        printf("Ctrl+C pressed. Shutting down...\n");
        shutdownProgram = true;
    }
}

//  Example async func for future usage
DWORD WINAPI exampleAsyncFunction(LPVOID lpParam) {
    while (!shutdownProgram) {
        // Simulate some work
        Sleep(1000); // Sleep for 1 second

        // Update the shared variable
        WaitForSingleObject(hExampleFunction, INFINITE);
        sharedVariable++;
        ReleaseMutex(hExampleFunction);
    }
    return 0; // This line will be reached when shutdownProgram is true
}

void SetupDebugMode(int argc, char* argv[]){
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "-debug") == 0) {
            debugEnabled = true;
            okay("Debug mode enabled.\n");
        }
    }
}

void initialize_global_variables(){
    for (int i = 0; i < sizeof(list_of_tracked_PIDs) / sizeof(list_of_tracked_PIDs[0]); i++){
        list_of_tracked_PIDs[i].id        = -1;
        list_of_tracked_PIDs[i].hookPID   = -1;
        list_of_tracked_PIDs[i].procName = (char*)malloc(128);
        strcpy(list_of_tracked_PIDs[i].procName, "");
        list_of_tracked_PIDs[i].counter   = nullptr;
    }
}

void reset_global_variable_at_address(int i){
    while (list_of_tracked_PIDs[i].id != -1){
        list_of_tracked_PIDs[i].id        = list_of_tracked_PIDs[i+1].id;
        list_of_tracked_PIDs[i].hookPID   = list_of_tracked_PIDs[i+1].hookPID;
        list_of_tracked_PIDs[i].procName  = list_of_tracked_PIDs[i+1].procName;
        list_of_tracked_PIDs[i].counter   = list_of_tracked_PIDs[i+1].counter;
        i++;
    }
}

// Remember to check if procName is valid (getRemoteProcAddress must reutnr something)
BOOLEAN update_GlobalFunctionsCounter(const char* procName) {
    int i = 0;
    while (GlobalFunctionsCounter[i].procName) {
        //debug("Is running %d %d %s", i, GlobalFunctionsCounter[i].counter, GlobalFunctionsCounter[i].procName);
        if(strcmp(GlobalFunctionsCounter[i].procName, procName) == 0){ return TRUE; }
        //printf("WorkingInside %d, %s\n", i, GlobalFunctionsCounter[i].procName);
        i++;
    }
    GlobalFunctionsCounter[i].counter  = 0;
    GlobalFunctionsCounter[i].procName = (char*)malloc(strlen(procName) + 1);
    strcpy(GlobalFunctionsCounter[i].procName, procName);
    GlobalFunctionsCounter[i].numberOfPublishers  = 0;
    debug("[update_GlobalFunctionsCounter] %d, %p, %s", i, &GlobalFunctionsCounter[i].counter, GlobalFunctionsCounter[i].procName);
    return TRUE;
}

BOOLEAN insert_to_list_of_tracked_PIDs(int newHookPid, LPVOID lpAddress, const char* procName){
    int i = 0;
    while (list_of_tracked_PIDs[i].id != -1){
        i++;
    }
    list_of_tracked_PIDs[i].id = i;
    list_of_tracked_PIDs[i].hookPID  = newHookPid;
    list_of_tracked_PIDs[i].procName = (char*)malloc(strlen(procName) + 1);
    strcpy(list_of_tracked_PIDs[i].procName, procName);
    list_of_tracked_PIDs[i].counter  = lpAddress;
    debug("[increment_list_of_tracked_PIDs] %d, %d, %s, %p", list_of_tracked_PIDs[i].id, list_of_tracked_PIDs[i].hookPID, list_of_tracked_PIDs[i].procName, list_of_tracked_PIDs[i].counter);
    
    update_GlobalFunctionsCounter(procName);
    return TRUE;
}

void update_global_variables() {
    //debug("[update_global_variables] %p %s %d", &GlobalFunctionsCounter[0].counter, GlobalFunctionsCounter[0].procName, list_of_tracked_PIDs[0].id);
    debug("Reseting lpCounter");
    
    int k = 0;
    while (GlobalFunctionsCounter[k].procName){ 
        GlobalFunctionsCounter[k].counter = 0; 
        GlobalFunctionsCounter[k].numberOfPublishers = 0; 
        k++;
    }

    int i = 0;
    while ( true ){
        debug("%d %p %d %d %s", i, list_of_tracked_PIDs[i].counter, list_of_tracked_PIDs[i].hookPID, list_of_tracked_PIDs[i].id, list_of_tracked_PIDs[i].procName);
        if (list_of_tracked_PIDs[i].id == -1) { debug("break"); break; }
        int j = 0;
        while (GlobalFunctionsCounter[j].procName) {
            if (strcmp(list_of_tracked_PIDs[i].procName, GlobalFunctionsCounter[j].procName) == 0) {
                int value_in_memory_of_process = PleaseReadProcessMemory(list_of_tracked_PIDs[i].hookPID, list_of_tracked_PIDs[i].counter);
                GlobalFunctionsCounter[j].numberOfPublishers += 1;
                if (value_in_memory_of_process != -1){
                    GlobalFunctionsCounter[j].counter += value_in_memory_of_process;
                }
                else {
                    reset_global_variable_at_address(i);
                }
                debug("[list_of_tracked_PIDs] %d, %d, %d, %s, %p", i, list_of_tracked_PIDs[i].id, list_of_tracked_PIDs[i].hookPID, list_of_tracked_PIDs[i].procName, list_of_tracked_PIDs[i].counter);
                info("HookedPID       : %d", list_of_tracked_PIDs[i].hookPID);
                info("Function Tracked: %s", list_of_tracked_PIDs[i].procName);
                info("Address used    : %p", list_of_tracked_PIDs[i].counter);  // Make it uppercase
                printf("\n");
                break;
            } 
            j++;
        }
        i++;
    }

    k = 0;
    BOOL temp_printed_something = FALSE;
    while (GlobalFunctionsCounter[k].procName){
        debug("[value_in_memory_of_process] %s %d %p", GlobalFunctionsCounter[k].procName, GlobalFunctionsCounter[k].counter, GlobalFunctionsCounter[k].counter);
        if (GlobalFunctionsCounter[k].counter != 0){
            info("Number of calls of %s (%d): %d", GlobalFunctionsCounter[k].procName, GlobalFunctionsCounter[k].numberOfPublishers, GlobalFunctionsCounter[k].counter);
            temp_printed_something = TRUE;
        }
        k++;
    }
    if (!temp_printed_something){
        info("No function was called");
    }
}

void read_variables_values(){
    info("Variables Values:\n");

    WaitForSingleObject(hExampleFunction, INFINITE);
    debug("[sharedVariable] %d", sharedVariable);
    ReleaseMutex(hExampleFunction);
    
    update_global_variables();

    printf("\n");
}

bool create_thread_for_async_function(HANDLE &useThisHandle, LPTHREAD_START_ROUTINE useThisFunction){
    useThisHandle = CreateMutex(NULL, FALSE, NULL);

    if (useThisHandle == NULL) {
        printf("CreateMutex error: %lu\n", GetLastError());
        return FALSE;
    }

    printf("Starting long-running function asynchronously...\n");

    // Create a thread to run the long-running function
    DWORD threadId;
    HANDLE hThread = CreateThread(
        NULL,                    // default security attributes
        0,                       // use default stack size
        useThisFunction,         // thread function name
        NULL,                    // argument to thread function
        0,                       // use default creation flags
        &threadId);              // returns the thread identifier

    if (hThread == NULL) {
        printf("[CreateThread] Error: %lu\n", GetLastError());
        CloseHandle(useThisHandle);
        return FALSE;
    }

    // Wait for the thread to finish (which will never happen in this case)
    WaitForSingleObject(hThread, INFINITE);
    ReleaseMutex(hThread);  // I actually forgot to put that...
    CloseHandle(useThisHandle);
    return TRUE;
}

void asyncRoutines() {
    //create_thread_for_async_function(hExampleFunction, exampleAsyncFunction);
}

BOOLEAN call_hook(){
    info("dllhook start");
    int hookPID;
    info("Insert hookPID");
    scanf("%d", &hookPID);
    char nameOfFunctionToTrack[256];
    info("Insert name of function");
    scanf("%255s", nameOfFunctionToTrack);

    //read_variables_values();
    //const char* nameOfFunctionToTrack = "NtOpenProcess";

    if (hookPID == -1) {
        const char* processName = "Notepad.exe";
        const char* processPath = "C:\\Windows\\System32\\notepad.exe";
        OpenExecutable(processPath);
        hookPID = GetPIDByProcessName(processName, 10000);
        //printf("%d\n", hookPID);
        //system("pause");
    }

    if (strcmp(nameOfFunctionToTrack, "all") == 0){
        system("cls");
        info("Starting massive hook attempts!");
        char** stringList = ListExportedNtFunctions(hookPID, "ntdll.dll");
        if (stringList){
            //for (int i = 0; stringList[i] != nullptr; i++){
                //info("Function detected %s %d", stringList[i], i);
            //}
            for (int i = 0; stringList[i] != nullptr ; i++) {
                debug("[call_hook] %d %s", hookPID, stringList[i]);
                LPVOID lpAddress = injectCode(hookPID, "ntdll.dll", stringList[i]);
                //debug("[injectCode call_hook] %p", lpAddress);
                if (lpAddress){
                    insert_to_list_of_tracked_PIDs(hookPID, lpAddress, stringList[i]);
                    okay("  Success (%d) %s", i, stringList[i]);
                }
                else {
                    warn("  Failed to hook (%d) %s", i, stringList[i]);
                    DWORD last_error = GetLastError();
                    warn("      Error: %lx", last_error);
                    //printf("%lu\n", last_error);
                    if ((last_error == 0x12b) || (last_error == 0x55) || (last_error == 0x57)){
                        break;
                    }
                }
                delete[] stringList[i];
                system("pause");
            }
            delete[] stringList;
        }
    } else {
        info("Trying do inject hook in %d of function %s", hookPID, nameOfFunctionToTrack);
        LPVOID lpAddress = injectCode(hookPID, "ntdll.dll", nameOfFunctionToTrack);
        if (lpAddress){
            okay("Hook Success!");
            //debug("[injectCode call_hook] %p", lpAddress);
            insert_to_list_of_tracked_PIDs(hookPID, lpAddress, nameOfFunctionToTrack);
            okay("Hook counter added!");
        } else {
            warn("Failed to hook %d", hookPID);
            warn("Error: %lx", GetLastError());
        }
        
    }

    //read_variables_values();
    system("pause");
    system("cls");
    return TRUE;
}

void mainRoutine() {
    // Periodically check the shared variable
    int menu_action = 0;

    menu_info();
    while (!shutdownProgram) {
        /*
            // Read the shared variable
            WaitForSingleObject(hMutex, INFINITE);
            int currentValue = sharedVariable;
            ReleaseMutex(hMutex);

            printf("Current value of shared variable: %d\n", currentValue);
        */
        scanf("%d", &menu_action);  // If i enter a char it breaks
        switch (menu_action) {
            case 1: {
                system("cls");
                call_hook();
                menu_info();
                break;
            }
            case 2:
                menu_info();
                break;
            case 3:
                system("cls");
                menu_info();
                break;
            case 4: {
                system("cls");
                read_variables_values();
                menu_info();
                break;
            }
            case -1: {  // Remember to remove
                system("cls");
                // Read the shared variable
                WaitForSingleObject(hExampleFunction, INFINITE);
                int currentValue = sharedVariable;
                ReleaseMutex(hExampleFunction);

                debug("[hExampleFunction] [sharedVariable]: %d\n", currentValue);
                menu_info();
                break;
            }
            default:
                system("cls");
                warn("Non implemented action\n");
                menu_info();
                break;
        }
    }
}

int main(int argc, char* argv[]) {

    system("cls");
    SetupDebugMode(argc, argv);

    // Register signal handler
    signal(SIGINT, signalHandler);

    initialize_global_variables();
    std::thread asyncThread(asyncRoutines);

    // Run the main routine in the main thread
    mainRoutine();

    // Set the shutdown flag and wait for the async thread to finish
    shutdownProgram = true;
    asyncThread.join();

    return 0;
}
