#include "../imports.h"
#include "functions_header.h"
#include <psapi.h>
#include <TlHelp32.h>

#pragma comment(lib, "psapi.lib")

/*
    This code args are 
    hookPid: what PID we r going to inject code into
    protectPid: what PID we want to deny access with OpenProcess
    
    Remember to run 
    gcc -o .\creating-hookDll.exe .\creating-hookDll.cpp
*/

// Saddly i could only think of redefining my macro :(
#undef debug
#define debug(msg, ...) do { if (debugEnabled) printf("[%] " msg "\n", ##__VA_ARGS__); } while (0)

BOOLEAN OpenExecutable(const char* processName) {
    //ShellExecuteW is way simplier than CreateProcessW and i dont know why
    HINSTANCE hInstance = ShellExecuteA(
        NULL,          // No parent window
        "open",       // Operation to perform
        processName,   // File to open
        NULL,          // No parameters
        NULL,          // No default directory
        SW_SHOWNORMAL  // Show the window normally
    );
    if (!hInstance) {
        warn("Failed to open executable. Error: %lx\n", GetLastError());
        return false;
    }

    Sleep(500);
    return true;
}

DWORD GetPIDByProcessName(const char* processName, DWORD timeoutMilliseconds) {
    DWORD pid = 0;
    DWORD maxMemoryUsage = 0;
    DWORD startTime = GetTickCount(); // Get the current time

    while (true) {
        HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
        if (hSnapshot == INVALID_HANDLE_VALUE) {
            printf("CreateToolhelp32Snapshot failed. Error: %ld\n", GetLastError());
            return 0;
        }

        PROCESSENTRY32 pe;
        pe.dwSize = sizeof(pe);

        if (Process32First(hSnapshot, &pe)) {
            do {
                if (strcmp(pe.szExeFile, processName) == 0) {
                    HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pe.th32ProcessID);
                    if (hProcess) {
                        PROCESS_MEMORY_COUNTERS pmc;
                        if (GetProcessMemoryInfo(hProcess, &pmc, sizeof(pmc))) {
                            if (pmc.WorkingSetSize > maxMemoryUsage) {
                                maxMemoryUsage = pmc.WorkingSetSize;
                                pid = pe.th32ProcessID;
                            }
                        }
                        CloseHandle(hProcess);
                    }
                }
            } while (Process32Next(hSnapshot, &pe));
        }

        CloseHandle(hSnapshot);

        // Check if the timeout has been reached
        if (GetTickCount() - startTime > timeoutMilliseconds) {
            break;
        }

        // Wait a short period before checking again
        Sleep(500); // Sleep for 500 milliseconds
    }

    return pid;
}

int PleaseReadProcessMemory(int hookPID, LPVOID lpAddress){
    int retval = 0;
    HANDLE hProcess = OpenProcess(PROCESS_VM_READ, FALSE, hookPID);
    if (!hProcess){ 
        //warn("[PleaseReadProcessMemory][OpenProcess] failed, Error %lx", GetLastError());
        return -1;
    }

    BOOL success = ReadProcessMemory(hProcess, lpAddress, &retval, sizeof(retval), NULL);
    if (success) {
        //info("[PleaseReadProcessMemory][ReadProcessMemory] success");
    } else {
        //warn("[PleaseReadProcessMemory][ReadProcessMemory] failed, Error %lx", GetLastError());
        return -1;
    }

    CloseHandle(hProcess);

    return retval;
}

/* Get id of ntdll function */
int GetIDOfNtdllSyscall(LPVOID lpProcAddress){
    lpProcAddress = reinterpret_cast<unsigned char*>(lpProcAddress) + 4;  // What im doing there?
    return *(int*)lpProcAddress;
}

/* Get assembly hexcode of function */
unsigned char* GetAssemblyCode(int hookPid, const char* dllName = NULL, const char* functionName = NULL){
    
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, hookPid);

    static unsigned char shellcodeExtracted[] = {
        // NtOpenProcess syscall
        0x4C, 0x8B, 0xD1,               // mov r10, rcx
        0xB8, 0x23, 0x00, 0x00, 0x00,   // mov eax, 0x23 (syscall id for NtOpenProcess)
        0x0F, 0x05,                     // syscall
        0xC3,                           // ret
    };

    if(!dllName)      { dllName     = "ntdll.dll";     };
    if(!functionName) {functionName = "NtAccessCheck"; };

    LPVOID lpProcAddress = getRemoteProcAddress(hookPid, dllName, functionName);
    int IdOfProc = GetIDOfNtdllSyscall(lpProcAddress);
    //debug("[GetIDOfNtdllSyscall] %x %p %s", IdOfProc, lpProcAddress, functionName);
    memcpy(&shellcodeExtracted[4], &IdOfProc,  sizeof(int));
    if (debugEnabled){
        printf("Shellcode Extracted:\n");
        for (int i = 0; i < (long)(sizeof(shellcodeExtracted)); ++i) {
            printf("%02X ", shellcodeExtracted[i]);
        }
        printf("\n");
    }

    //lpNtdllFirstFunction = reinterpret_cast<unsigned char*>(lpNtdllFirstFunction) + 4;
    //debug("[GetAssemblyCode] %p %x", lpNtdllFirstFunction, *(int*)lpNtdllFirstFunction);
    return shellcodeExtracted;
}

/*  Description:
    Write no function instruction (nop) to shellcode
*/
BOOL writeNOPs(HANDLE hProcess, LPVOID lpAddress, int numBytes) {
    //  retval return TRUE if writing finished without errors.
	BOOL retval = FALSE;

    //  Alloc memory for a array of numBytes chars. 
	char* nopArray = (char*)calloc(numBytes, sizeof(char));
	char nop = 0x90;  //Hex code for "do nothing"
	for (int i = 0; i < numBytes; i++) {
		memcpy(&nopArray[i], &nop, 1);  //  Fill buffer with NOP bytes
	}

	if (hProcess) {
		SIZE_T numBytesWritten = 0;
		if (WriteProcessMemory(hProcess, lpAddress, nopArray, numBytes, &numBytesWritten)) {
            //  Write NOPs to remote process
			if (numBytesWritten == numBytes)
				retval = TRUE;
		}
	}

	return retval;
}

/*  Description:
        Inject code in hProcess to deny access to protectPID,
        modifying NtOpenProcess (located at ntdll.dll, appear in Ntddk.h)
        (Which is called by OpenProcess in Kernel32.dll (WindowsAPI))
*/
PointerPair injectTrampoline(HANDLE hProcess, LPVOID hookAtAddress){
    PointerPair pair;
    //  Using values in [0, 255]
    unsigned char trampolineOpcodes[] = {
        // Increment value at the address pointed by lpCounter
        0x48, 0xB8,             // mov rax, dword ptr
        /*
            0x48: REX prefix indicating a 64-bit instruction. 
            0xB8: Opcode for the mov r64, imm64 instruction.
        */
        0x00, 0x00, 0x00, 0x00, // [BOATCAKE]
        0x00, 0x00, 0x00, 0x00, // [BOATCAKE]
        0xFF, 0x00,             // inc dword ptr [rax]
        0x48, 0x31, 0xC0,       // xor rax rax
        0xC3,                   // ret

        // NtOpenProcess syscall
        0x4C, 0x8B, 0xD1,               // mov r10, rcx
        0xB8, 0x23, 0x00, 0x00, 0x00,   // mov eax, 0x23 (syscall number for NtOpenProcess)
        0x0F, 0x05,                     // syscall
        0xC3,                           // ret
    };
	
    LPVOID lpLocalCounter = VirtualAllocEx(hProcess, 0, sizeof(DWORD), MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if (!lpLocalCounter){
        warn("[lpLocalCounter] failed, Error %lx", GetLastError());
        return pair;
    }
    //debug("[lpLocalCounter] success");
    debug("[lpLocalCounter] %p", lpLocalCounter);
    //VirtualFreeEx(hProcess, lpLocalCounter, 0, MEM_RELEASE);  //  MOTHERFUCKER
    
    memcpy(&trampolineOpcodes[2],  &lpLocalCounter, sizeof(LPVOID));  

    // Now we patch the line related to mov eax, 0x23 (changing the 0x23 ID of syscall)
    int uniqueIDNtProc = GetIDOfNtdllSyscall(hookAtAddress);
    memcpy(&trampolineOpcodes[20], &uniqueIDNtProc, sizeof(int));

    long sizeOfTrampoline = sizeof(trampolineOpcodes);                
    if (debugEnabled){
        printf("Trampoline Opcodes:\n");
        for (int i = 0; i < sizeOfTrampoline; ++i) {
            printf("%02X ", trampolineOpcodes[i]);
        }
        printf("\n");
    }

    //  Base address of hProcess with SIZE_T, type and permissions.
	LPVOID lpAddressTrampoline = VirtualAllocEx(hProcess, 0, sizeOfTrampoline, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    // LPVOID lpAddress = 0 makes the function determine where to allocate.
    if (!lpAddressTrampoline){
        warn("[VirtualAllocEx] failed, Error %lx", GetLastError());
        return pair;
    }
    //debug("[lpAddressTrampoline] success");
    debug("[lpAddressTrampoline] %p", lpAddressTrampoline);

    SIZE_T bytesWritten = 0;
    //  Write trampolineOpcodes with size sizeOfTrampoline in hProcess (With write permissions), 
    //  on address lpAddressTrampoline. Saving the number of bytes written on bytesWritten and them
    //  compare to check if the injection worked.
	if (WriteProcessMemory(hProcess, lpAddressTrampoline, trampolineOpcodes, sizeOfTrampoline, &bytesWritten) && bytesWritten == sizeOfTrampoline) {
		//debug("[WriteProcessMemory] success");
	}
	else {
		warn("[WriteProcessMemory] at %0x4 failed, Error %lx", lpAddressTrampoline, GetLastError());
		VirtualFreeEx(hProcess, lpAddressTrampoline, 0, MEM_RELEASE);
	}

    //  Return the address of the trampoline injected shellcode
    //debug("[injectTrampoline LPVOID lpAddressTrampoline]: %p", lpAddressTrampoline);
    pair.lpLocalCounter = lpLocalCounter;
    pair.lpAddressTrampoline = lpAddressTrampoline;
    return pair;

}

char** ListExportedNtFunctions(int pid, const char* dllName) {
    HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);
    if (hProcess == NULL) {
        //  Failed to open the process
        warn("[OpenProcess] failed, Error %lx", GetLastError());
        return NULL;
    }
    debug("[OpenProcess] success");

    HMODULE hModule = GetModuleHandle(dllName);
    if (hModule == NULL) {
        //  Failed to get handle to process
        warn("[GetModuleHandle] failed, Error %lx", GetLastError());
        return NULL;
    }
    debug("[GetModuleHandle] success");
    
    BYTE* moduleBase = reinterpret_cast<BYTE*>(hModule);
    IMAGE_DOS_HEADER dosHeader;
    IMAGE_NT_HEADERS ntHeaders;

    SIZE_T bytesRead;
    ReadProcessMemory(hProcess, moduleBase, &dosHeader, sizeof(dosHeader), &bytesRead);
    ReadProcessMemory(hProcess, moduleBase + dosHeader.e_lfanew, &ntHeaders, sizeof(ntHeaders), &bytesRead);

    IMAGE_EXPORT_DIRECTORY exportDir;
    DWORD exportDirRVA = ntHeaders.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
    ReadProcessMemory(hProcess, moduleBase + exportDirRVA, &exportDir, sizeof(exportDir), &bytesRead);

    DWORD* nameRVAs = new DWORD[exportDir.NumberOfNames];
    ReadProcessMemory(hProcess, moduleBase + exportDir.AddressOfNames, nameRVAs, exportDir.NumberOfNames * sizeof(DWORD), &bytesRead);


    char** stringList = new char*[exportDir.NumberOfNames];
    DWORD validIndex = 0;

    for (DWORD i = 0; i < exportDir.NumberOfNames; i++) {
        char functionName[256];
        if (ReadProcessMemory(hProcess, moduleBase + nameRVAs[i], functionName, sizeof(functionName), &bytesRead)) {
            if (strncmp(functionName, "Nt", 2) == 0) {
                stringList[validIndex] = new char[strlen(functionName) + 1];
                strcpy(stringList[validIndex], functionName);
                validIndex++; // Move to the next valid index in stringList
            }
        }
        if (validIndex >= exportDir.NumberOfNames) {
            break;
        }
    }

    delete[] nameRVAs;
    //return stringList;
    // Resize stringList to only hold valid entries if needed
    char** redactedStringList = new char*[validIndex + 1];
    for (DWORD i = 0; i < validIndex; i++) {
        redactedStringList[i] = new char[strlen(stringList[i]) + 1];
        strcpy(redactedStringList[i], stringList[i]);
        //redactedStringList[i][strlen(stringList[i])] = '\0';
    }
    redactedStringList[validIndex] = nullptr;

    // Cleanup original stringList
    for (DWORD i = 0; i < validIndex; i++) {
        if (stringList[i] != nullptr) {
            //printf("%s, %p, %d\n", stringList[i], (LPVOID*)stringList[i], i);
            delete[] stringList[i];
        }
    }
    delete[] stringList;
    CloseHandle(hProcess);

    return redactedStringList; // Return trimmed list of function names
}

/*  Description:
        Return the memory address in a targetPid in which a function 
        procName from dllName is called (Its working i swear)
*/
void* getRemoteProcAddress(int pid, const char* dllName, const char* functionName) {
    MODULEINFO localModuleInfo;
    void* retval = nullptr;

    HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);
    if (hProcess == NULL) {
        //  Failed to open the process
        warn("[OpenProcess] failed, Error %lx", GetLastError());
        return nullptr;
    }
    //debug("[OpenProcess] success");

    DWORD reqSizeOfBuffer = 0;
    if (EnumProcessModules(hProcess, nullptr, 0, &reqSizeOfBuffer)) {
        HMODULE* hModules = (HMODULE*)malloc(reqSizeOfBuffer);
        if (EnumProcessModules(hProcess, hModules, reqSizeOfBuffer, &reqSizeOfBuffer)) {
            for (unsigned int i = 0; i < (reqSizeOfBuffer / sizeof(HMODULE)); i++) {
                TCHAR moduleName[MAX_PATH];
                if (GetModuleBaseName(hProcess, hModules[i], moduleName, MAX_PATH) <= 256) {
                    if (_stricmp(moduleName, dllName) == 0) {
                        if (GetModuleInformation(hProcess, hModules[i], &localModuleInfo, sizeof(localModuleInfo))) {
                            HMODULE localModuleAddress = GetModuleHandle(dllName);
                            FARPROC localProcAddress = GetProcAddress(localModuleAddress, functionName);
                            DWORD_PTR offset = (DWORD_PTR)localProcAddress - (DWORD_PTR)localModuleInfo.lpBaseOfDll;
                            retval = (void*)((DWORD_PTR)hModules[i] + offset);
                            //debug("[getRemoteProcAddress DWORD_PTR hModules[i]]: 0x%llx", (unsigned long long)hModules[i]);
                            //debug("[getRemoteProcAddress DWORD_PTR offset]     : 0x%llx", (unsigned long long)offset);
                            break;
                        }
                    }
                }
            }
        }
        free(hModules); //  Free allocated memory
    }
    CloseHandle(hProcess);
    //debug("[getRemoteProcAddress LPVOID retval]: %p", retval);
    return retval;
    //  Mental note: add images im saving on whatsapp to the documentation
    //  at some point
}

/*  Description:
        Primary function, inject shellcode by calling getRemoteProcAddress, 
        injectTrampoline and writeNOPs
*/
LPVOID injectCode(int hookPid, const char* dllName, const char* functionName){
    //injectCode(hookPid, protectPid, "ntdll.dll", "NtOpenProcess", lpCounter);
    LPVOID retval = NULL;
	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, hookPid);
    if (!hProcess){ 
        debug("[OpenProcess] failed, Error %lx", GetLastError());
        debug("[hookPid, dllName, functionName] %d %s %s", hookPid, dllName, functionName);
        return nullptr;
    }

    //  Calls personalized getProcAddress function
	LPVOID hookAtAddress = getRemoteProcAddress(hookPid, dllName, functionName);
    /*  Address of function call
        Returns a address of hookPID in which procName of dllName is called.
        Just access the memory address with x64 or something
        Or press shift+D and find the function... You choose
    */ 
    if (!hookAtAddress) {
        debug("[getRemoteProcAddress] failed, Error %lx", GetLastError());
        debug("[hookPid, dllName, functionName] %d %s %s", hookPid, dllName, functionName);
        return nullptr;
    }

    //  Calls personalized shellcode injection function
    PointerPair retvalinject = injectTrampoline(hProcess, hookAtAddress);
	LPVOID trampolineAddress = retvalinject.lpAddressTrampoline;
    LPVOID lpLocalCounter    = retvalinject.lpLocalCounter;
    //  Address to the modified ntdll function

    if (!trampolineAddress) {
        debug("[injectTrampoline] failed, Error %lx", GetLastError());
        debug("[hookPid, dllName, functionName] %d %s %s", hookPid, dllName, functionName);
        return nullptr;
    }

    unsigned char jumpBytes[] = { 
        0x48, 0xB8,              //  REX.W  mov rax, imm64
        0x4B, 0x4E, 0x41, 0x42,  //  "FOOD" (lower 4 bytes of the 64-bit value)
        0x44, 0x4F, 0x4F, 0x46,  //  "BANK" (upper 4 bytes of the 64-bit value)
        0xFF, 0xE0               //  jmp rax
    };
    /*
        ?
    */

    //  Overwrite {...,0x46, 0x4F, 0x4F, 0x44,...} with the address of trampolineAddress
	memcpy(&jumpBytes[2], &trampolineAddress, 8); //  Patch FOOD to trampolineAddress
	int sizeOfJumpBytes = sizeof(jumpBytes);

    if (writeNOPs(hProcess, hookAtAddress, 11)) {
        //  NOP out 11 bytes in remote process at hookAtAddress
        //  Cleaning memory to insert jumpBytes without conflicts
		
		SIZE_T numBytesWritten = 0;
		if (!WriteProcessMemory(hProcess, hookAtAddress, jumpBytes, sizeOfJumpBytes, &numBytesWritten) || numBytesWritten != sizeOfJumpBytes) { 
            //  Write jumpBytes to remote process
			warn("[WriteProcessMemory] at %0x4 failed, Error %lx", hookAtAddress, GetLastError());
		}
		else {
			//debug("[WriteProcessMemory] success");
		}
	}
    else {
        warn("[writeNOPs] failed, Error %lx", GetLastError());
    }

    CloseHandle(hProcess);
    return lpLocalCounter;
}
