#include <windows.h>
#include <psapi.h>
#include <stdio.h>

#pragma comment(lib, "Psapi.lib")

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO {
    HANDLE  HandleValue;
    UCHAR   ObjectTypeIndex;
    UCHAR   Flags;
    USHORT  HandleAttributes;
    ULONG   Reserved;
    PVOID   Object;
    ACCESS_MASK GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION {
    ULONG NumberOfHandles;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION;

typedef enum _SYSTEM_INFORMATION_CLASS {
    SystemHandleInformation = 16
} SYSTEM_INFORMATION_CLASS;

typedef NTSTATUS (NTAPI *pNtQuerySystemInformation)(
    SYSTEM_INFORMATION_CLASS SystemInformationClass,
    PVOID SystemInformation,
    ULONG SystemInformationLength,
    PULONG ReturnLength
);

#define STATUS_INFO_LENGTH_MISMATCH 0xC0000004
#define STATUS_SUCCESS 0x00000000

void GetHandlesForProcess(DWORD pid) {
    SYSTEM_HANDLE_INFORMATION* handleInfo = nullptr;
    ULONG length = 0x10000;
    NTSTATUS status = STATUS_INFO_LENGTH_MISMATCH;

    // Load NtQuerySystemInformation function
    HMODULE ntdll = GetModuleHandle(TEXT("ntdll.dll"));
    pNtQuerySystemInformation NtQuerySystemInformation = (pNtQuerySystemInformation)GetProcAddress(ntdll, "NtQuerySystemInformation");

    if (!NtQuerySystemInformation) {
        printf("Failed to get NtQuerySystemInformation address\n");
        return;
    }

    // Allocate initial buffer
    handleInfo = (SYSTEM_HANDLE_INFORMATION*)malloc(length);
    if (handleInfo == nullptr) {
        printf("Memory allocation failed\n");
        return;
    }

    // Query system handle information
    while (status == STATUS_INFO_LENGTH_MISMATCH) {
        status = NtQuerySystemInformation(SystemHandleInformation, handleInfo, length, &length);

        if (status == STATUS_INFO_LENGTH_MISMATCH) {
            free(handleInfo);
            handleInfo = (SYSTEM_HANDLE_INFORMATION*)malloc(length);
            if (handleInfo == nullptr) {
                printf("Memory allocation failed\n");
                return;
            }
        }
    }

    if (status != STATUS_SUCCESS) {
        printf("Failed to query system handle information, status code: %lx\n", status);
        free(handleInfo);
        return;
    }

    SYSTEM_HANDLE_TABLE_ENTRY_INFO* handles = handleInfo->Handles;
    ULONG handleCount = handleInfo->NumberOfHandles;
    printf("Total handles: %lu\n", handleCount);

    // Iterate over handles and filter by process ID
    for (ULONG i = 0; i < handleCount; ++i) {
        if (handles[i].Object == nullptr) {
            printf("Invalid handle object pointer at index %lu\n", i);
            continue;
        }

        // Debug information about the handle
        printf("Handle at index %lu: %p\n", i, handles[i].HandleValue);

        // Check if handle belongs to the process
        if ((DWORD_PTR)handles[i].Object == pid) {
            printf("Handle for PID %lu: %p\n", pid, handles[i].HandleValue);
        }
    }

    free(handleInfo);
}

int main(int argc, char* argv[]) {
    if (argc != 2) {
        printf("Usage: %s <PID>\n", argv[0]);
        return 1;
    }

    char* endptr;
    DWORD pid = (DWORD)strtoul(argv[1], &endptr, 10);

    if (*endptr != '\0') {
        printf("Invalid PID: %s\n", argv[1]);
        return 1;
    }

    GetHandlesForProcess(pid);
    return 0;
}
